"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[84095,62272],{51211:(e,t,r)=>{r.d(t,{Z:()=>w});var n,o=r(36663),s=r(80085),i=r(25709),a=r(82064),l=r(67134),u=r(81977),c=(r(39994),r(13802),r(34248)),p=r(40266),f=r(39835),y=r(14685),m=r(53736),h=r(59659),g=r(12512);const d=new i.X({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let x=n=class extends a.Z{constructor(e){super(e),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(e,t){return this.readFeaturesWithClass(e,t,s.Z)}writeGeometryType(e,t,r,n){if(e)return void d.write(e,t,r,n);const{features:o}=this;if(o)for(const e of o)if(null!=e?.geometry)return void d.write(e.geometry.type,t,r,n)}readQueryGeometry(e,t){if(!e)return null;const r=!!e.spatialReference,n=(0,m.im)(e);return n&&!r&&t.spatialReference&&(n.spatialReference=y.Z.fromJSON(t.spatialReference)),n}writeSpatialReference(e,t){if(e)return void(t.spatialReference=e.toJSON());const{features:r}=this;if(r)for(const e of r)if(e&&null!=e.geometry&&e.geometry.spatialReference)return void(t.spatialReference=e.geometry.spatialReference.toJSON())}clone(){return new n(this.cloneProperties())}cloneProperties(){return(0,l.d9)({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(e){const t=this.write();if(t.features&&Array.isArray(e)&&e.length>0)for(let r=0;r<t.features.length;r++){const n=t.features[r];if(n.geometry){const t=e?.[r];n.geometry=t?.toJSON()||n.geometry}}return t}quantize(e){const{scale:[t,r],translate:[n,o]}=e,s=this.features,i=this._getQuantizationFunction(this.geometryType,(e=>Math.round((e-n)/t)),(e=>Math.round((o-e)/r)));for(let e=0,t=s.length;e<t;e++)i?.(s[e].geometry)||(s.splice(e,1),e--,t--);return this.transform=e,this}unquantize(){const{geometryType:e,features:t,transform:r}=this;if(!r)return this;const{translate:[n,o],scale:[s,i]}=r;let a=null,l=null;if(this.hasZ&&null!=r?.scale?.[2]){const{translate:[,,e],scale:[,,t]}=r;a=r=>r*t+e}if(this.hasM&&null!=r?.scale?.[3]){const{translate:[,,,e],scale:[,,,t]}=r;l=r=>null==r?r:r*t+e}const u=this._getHydrationFunction(e,(e=>e*s+n),(e=>o-e*i),a,l);for(const{geometry:e}of t)null!=e&&u&&u(e);return this.transform=null,this}readFeaturesWithClass(e,t,r){const n=y.Z.fromJSON(t.spatialReference),o=[];for(let t=0;t<e.length;t++){const s=e[t],i=r.fromJSON(s),a=s.geometry?.spatialReference;null==i.geometry||a||(i.geometry.spatialReference=n);const l=s.aggregateGeometries,u=i.aggregateGeometries;if(l&&null!=u)for(const e in u){const t=u[e],r=l[e]?.spatialReference;null==t||r||(t.spatialReference=n)}o.push(i)}return o}_quantizePoints(e,t,r){let n,o;const s=[];for(let i=0,a=e.length;i<a;i++){const a=e[i];if(i>0){const e=t(a[0]),i=r(a[1]);e===n&&i===o||(s.push([e-n,i-o]),n=e,o=i)}else n=t(a[0]),o=r(a[1]),s.push([n,o])}return s.length>0?s:null}_getQuantizationFunction(e,t,r){return"point"===e?e=>(e.x=t(e.x),e.y=r(e.y),e):"polyline"===e||"polygon"===e?e=>{const n=(0,m.oU)(e)?e.rings:e.paths,o=[];for(let e=0,s=n.length;e<s;e++){const s=n[e],i=this._quantizePoints(s,t,r);i&&o.push(i)}return o.length>0?((0,m.oU)(e)?e.rings=o:e.paths=o,e):null}:"multipoint"===e?e=>{const n=this._quantizePoints(e.points,t,r);return n&&n.length>0?(e.points=n,e):null}:"extent"===e?e=>e:null}_getHydrationFunction(e,t,r,n,o){return"point"===e?e=>{e.x=t(e.x),e.y=r(e.y),n&&(e.z=n(e.z))}:"polyline"===e||"polygon"===e?e=>{const s=(0,m.oU)(e)?e.rings:e.paths;let i,a;for(let e=0,n=s.length;e<n;e++){const n=s[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];e>0?(i+=o[0],a+=o[1]):(i=o[0],a=o[1]),o[0]=t(i),o[1]=r(a)}}if(n&&o)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=n(r[2]),r[3]=o(r[3])}}else if(n)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=n(r[2])}}else if(o)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=o(r[2])}}}:"extent"===e?e=>{e.xmin=t(e.xmin),e.ymin=r(e.ymin),e.xmax=t(e.xmax),e.ymax=r(e.ymax),n&&null!=e.zmax&&null!=e.zmin&&(e.zmax=n(e.zmax),e.zmin=n(e.zmin)),o&&null!=e.mmax&&null!=e.mmin&&(e.mmax=o(e.mmax),e.mmin=o(e.mmin))}:"multipoint"===e?e=>{const s=e.points;let i,a;for(let e=0,n=s.length;e<n;e++){const n=s[e];e>0?(i+=n[0],a+=n[1]):(i=n[0],a=n[1]),n[0]=t(i),n[1]=r(a)}if(n&&o)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=n(t[2]),t[3]=o(t[3])}else if(n)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=n(t[2])}else if(o)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=o(t[2])}}:null}};(0,o._)([(0,u.Cb)({type:String,json:{write:!0}})],x.prototype,"displayFieldName",void 0),(0,o._)([(0,u.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],x.prototype,"exceededTransferLimit",void 0),(0,o._)([(0,u.Cb)({type:[s.Z],json:{write:!0}})],x.prototype,"features",void 0),(0,o._)([(0,c.r)("features")],x.prototype,"readFeatures",null),(0,o._)([(0,u.Cb)({type:[g.Z],json:{write:!0}})],x.prototype,"fields",void 0),(0,o._)([(0,u.Cb)({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:d.read}}})],x.prototype,"geometryType",void 0),(0,o._)([(0,f.c)("geometryType")],x.prototype,"writeGeometryType",null),(0,o._)([(0,u.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],x.prototype,"hasM",void 0),(0,o._)([(0,u.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],x.prototype,"hasZ",void 0),(0,o._)([(0,u.Cb)({types:h.qM,json:{write:!0}})],x.prototype,"queryGeometry",void 0),(0,o._)([(0,c.r)("queryGeometry")],x.prototype,"readQueryGeometry",null),(0,o._)([(0,u.Cb)({type:y.Z,json:{write:!0}})],x.prototype,"spatialReference",void 0),(0,o._)([(0,f.c)("spatialReference")],x.prototype,"writeSpatialReference",null),(0,o._)([(0,u.Cb)({json:{write:!0}})],x.prototype,"transform",void 0),x=n=(0,o._)([(0,p.j)("esri.rest.support.FeatureSet")],x),x.prototype.toJSON.isDefaultToJSON=!0;const w=x},36209:(e,t,r)=>{r.d(t,{A:()=>s,E:()=>i});var n=r(10186),o=r(68403);function s(e,t,r=a){return new n.Z({x:e[r.originX],y:e[r.originY],z:e[r.originZ],spatialReference:t})}function i(e,t=a){return new o.Z({translation:[e[t.translationX],-e[t.translationZ],e[t.translationY]],rotationAxis:[e[t.rotationX],-e[t.rotationZ],e[t.rotationY]],rotationAngle:e[t.rotationDeg],scale:[e[t.scaleX],e[t.scaleZ],e[t.scaleY]]})}const a={originX:"originX",originY:"originY",originZ:"originZ",translationX:"translationX",translationY:"translationY",translationZ:"translationZ",scaleX:"scaleX",scaleY:"scaleY",scaleZ:"scaleZ",rotationX:"rotationX",rotationY:"rotationY",rotationZ:"rotationZ",rotationDeg:"rotationDeg"}},84095:(e,t,r)=>{r.r(t),r.d(t,{assetMapFromAssetMapsJSON:()=>d,extractMesh:()=>m,meshFeatureSetFromJSON:()=>y});var n=r(80085),o=r(13802),s=r(86114),i=r(91772),a=r(15857),l=r(14685),u=r(57450),c=r(13449),p=r(51211),f=r(36209);function y(e,t,r){const o=r.features;r.features=[],delete r.geometryType;const s=p.Z.fromJSON(r);if(s.geometryType="mesh",!r.assetMaps)return s;const i=d(t,r.assetMaps),a=e.sourceSpatialReference??l.Z.WGS84,u=r.globalIdFieldName,{outFields:c}=e,f=null!=c&&c.length>0?(y=c.includes("*")?null:new Set(c),({attributes:e})=>{if(!e)return{};if(!y)return e;for(const t in e)y.has(t)||delete e[t];return e}):()=>({});var y;for(const e of o){const r=m(e,u,a,t,i);s.features.push(new n.Z({geometry:r,attributes:f(e)}))}return s}function m(e,t,r,n,o){const s=e.attributes[t],l=o.get(s);if(null==l||!e.geometry)return null;const c=(0,f.A)(e.attributes,r,n.transformFieldRoles),p=i.Z.fromJSON(e.geometry);p.spatialReference=r;const y=(0,f.E)(e.attributes,n.transformFieldRoles),m=r.isGeographic?"local":"georeferenced",g=function(e){const t=Array.from(e.files.values()),r=new Array;for(const e of t){if(e.status!==h.COMPLETED)return null;const t=new Array;for(const r of e.parts){if(!r)return null;t.push(new u.LL(r.url,r.hash))}r.push(new u.CP(e.name,e.mimeType,t))}return r}(l);return g?a.default.createWithExternalSource(c,g,{extent:p,transform:y,vertexSpace:m,unitConversionDisabled:!0}):a.default.createIncomplete(c,{extent:p,transform:y,vertexSpace:m})}var h,g;function d(e,t){const r=new Map;for(const n of t){const t=n.parentGlobalId;if(null==t)continue;const i=n.assetName,a=n.assetType,l=n.assetHash,u=n.assetURL,p=n.conversionStatus,f=n.seqNo,y=(0,c.d1)(a,e.supportedFormats);if(!y){o.Z.getLogger("esri.rest.support.meshFeatureSet").error("mesh-feature-set:unknown-format",`Service returned an asset of type ${a}, but it does not list it as a supported type`);continue}const m=(0,s.s1)(r,t,(()=>({files:new Map})));(0,s.s1)(m.files,i,(()=>({name:i,type:a,mimeType:y,status:x(p),parts:[]}))).parts[f]={hash:l,url:u}}return r}function x(e){switch(e){case"COMPLETED":case"SUBMITTED":return h.COMPLETED;case"INPROGRESS":return h.PENDING;default:return h.FAILED}}(g=h||(h={}))[g.FAILED=0]="FAILED",g[g.PENDING=1]="PENDING",g[g.COMPLETED=2]="COMPLETED"}}]);