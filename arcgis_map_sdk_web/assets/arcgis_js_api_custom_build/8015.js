"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[8015],{8015:(e,a,t)=>{t.r(a),t.d(a,{save:()=>R,saveAll:()=>k,saveAllAs:()=>z,saveAs:()=>F});var r=t(7753),n=(t(39994),t(70375)),o=t(50516),s=t(21011),i=t(20692),l=t(8308),c=t(54957),u=t(84513),y=t(31370);const f="Feature Service",p="feature-layer-utils",d=`${p}-save`,m=`${p}-save-as`,w=`${p}-saveall`,h=`${p}-saveall-as`;function b(e){return{isValid:(0,c.fP)(e)&&(!("dynamicDataSource"in e)||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function v(e,a){const t=(0,u.Y)(e,"portal-item");return a?.isTable&&(t.layerContainerType="tables"),t}function I(e){const a=v(e),t=v(e);return t.layerContainerType="tables",{forLayers:a,forTables:t}}function T(e){const a=[],t=[];for(const{layer:r,layerJSON:n}of e)r.isTable?t.push(n):a.push(n);return{layers:a,tables:t}}function S(e){return T([e])}async function P(e,a){return/\/\d+\/?$/.test(e.url)?S(a[0]):L(a,e)}async function L(e,a){if(e.reverse(),!a)return T(e);const r=await async function(e,a){let r=await e.fetchData("json");if(function(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}(r))return r;r||={},function(e){e.layers||=[],e.tables||=[]}(r);const{layer:{url:n,customParameters:o,apiKey:s}}=a[0];return await async function(e,a,r){const{url:n,customParameters:o,apiKey:s}=a,{serviceJSON:i,layersJSON:c}=await(0,l.V)(n,{customParameters:o,apiKey:s}),u=g(e.layers,i.layers,r),y=g(e.tables,i.tables,r);e.layers=u.itemResources,e.tables=y.itemResources;const f=[...u.added,...y.added],p=c?[...c.layers,...c.tables]:[];await async function(e,a,r,n){const o=await async function(e){const a=[];e.forEach((({type:e})=>{switch((0,l.W)(e)){case"CatalogLayer":a.push(Promise.all([t.e(96027),t.e(87676),t.e(42020)]).then(t.bind(t,47503)).then((e=>e.default)));break;case"FeatureLayer":a.push(Promise.all([t.e(41984),t.e(12926),t.e(97548)]).then(t.bind(t,12926)).then((e=>e.default)));break;case"OrientedImageryLayer":a.push(Promise.all([t.e(41984),t.e(12926),t.e(55299)]).then(t.bind(t,94365)).then((e=>e.default)))}}));const r=await Promise.all(a),n=new Map;return e.forEach((({type:e},a)=>{n.set(e,r[a])})),n}(a),s=a.map((({id:e,type:a})=>new(o.get(a))({url:r,layerId:e,sourceJSON:n.find((({id:a})=>a===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((a=>{const{layerId:t,loaded:r,defaultPopupTemplate:n}=a;if(!r||null==n)return;const o={id:t,popupInfo:n.toJSON()};"ArcGISFeatureLayer"!==a.operationalLayerType&&(o.layerType=a.operationalLayerType),O(a,o,e)}))}(e,f,n,p)}(r,{url:n??"",customParameters:o,apiKey:s},a.map((e=>e.layer.layerId))),r}(a,e);for(const a of e)O(a.layer,a.layerJSON,r);return function(e,a){const t=[],r=[];for(const{layer:e}of a){const{isTable:a,layerId:n}=e;a?r.push(n):t.push(n)}N(e.layers,t),N(e.tables,r)}(r,e),r}function N(e,a){if(e.length<2)return;const t=[];for(const{id:a}of e)t.push(a);(0,r.fS)(t.sort($),a.slice().sort($))&&e.sort(((e,t)=>{const r=a.indexOf(e.id),n=a.indexOf(t.id);return r<n?-1:r>n?1:0}))}function $(e,a){return e<a?-1:e>a?1:0}function g(e,a,t){const n=(0,r.e5)(e,a,((e,a)=>e.id===a.id));e=e.filter((e=>!n.removed.some((a=>a.id===e.id))));const o=n.added;return o.forEach((({id:a})=>{e.push({id:a})})),{itemResources:e,added:o.filter((({id:e})=>!t.includes(e)))}}function O(e,a,t){e.isTable?x(t.tables,a):x(t.layers,a)}function x(e,a){const t=e.findIndex((({id:e})=>e===a.id));-1===t?e.push(a):e[t]=a}function E(e,a){if(!e.length)throw new n.Z(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function A(e,a){const t=e.map((e=>e.layerId));if(new Set(t).size!==t.length)throw new n.Z(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function D(e){E(e,w),await Promise.all(e.map((e=>e.load())));for(const a of e)(0,s.DC)(a,w,b),(0,s.Ym)({layer:a,itemType:f,errorNamePrefix:w});(function(e,a){const t=e.map((e=>e.portalItem.id));if(new Set(t).size>1)throw new n.Z(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")})(e,w),A(e,w)}function C(e,a){let t=0,r=0,n=0;for(const{layerType:e}of[...a.layers,...a.tables])switch(e){case"OrientedImageryLayer":t++;break;case"SubtypeGroupLayer":r++;break;case"SubtypeGroupTable":n++}(0,y.IW)(e,y.hz.ORIENTED_IMAGERY_LAYER,t>0),(0,y.IW)(e,y.hz.SUBTYPE_GROUP_LAYER,r>0),(0,y.IW)(e,y.hz.SUBTYPE_GROUP_TABLE,n>0)}function J(e,a,t){(0,y.ck)(a,y.hz.METADATA),(0,y.IW)(a,y.hz.MULTI_LAYER,e.length>1),(0,y.IW)(a,y.hz.SINGLE_LAYER,1===e.length),(0,y.IW)(a,y.hz.TABLE,t.tables.length>0&&0===t.layers.length),C(a,t)}async function U(e,a,t){C(a,t)}async function Y(e,a,t){const{url:r,layerId:n,title:o,fullExtent:s,isTable:l}=e,c=(0,i.Qc)(r);a.url=("FeatureServer"===c?.serverType?r:`${r}/${n}`)??null,a.title||=o,a.extent=null,l||null==s||(a.extent=await(0,y.$o)(s)),J([e],a,t)}async function Z(e){E(e,h),await Promise.all(e.map((e=>e.load())));for(const a of e)(0,s.DC)(a,h,b);(function(e,a){for(const t of e){const r=t.parsedUrl.path,o=(0,i.Qc)(r),l=o?.url.path;if(!l)throw new n.Z(`${a}:invalid-parameters`,(0,s.xG)(t,`has unsupported url pattern: ${r}`),{layer:t});const c=o?.serverType;if("FeatureServer"!==c&&"MapServer"!==c)throw new n.Z(`${a}:invalid-parameters`,(0,s.xG)(t,`has unsupported server type: ${c}`),{layer:t});if("MapServer"===c&&e.length>1)throw new n.Z(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=(0,i.Qc)(e[0].parsedUrl.path)?.url.path;if(!e.every((e=>(0,i.Qc)(e.parsedUrl.path)?.url.path===t)))throw new n.Z(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")})(e,h),A(e,h)}async function R(e,a){return(0,s.a1)({layer:e,itemType:f,validateLayer:b,createJSONContext:a=>v(a,e),createItemData:(e,a)=>P(a,[e]),errorNamePrefix:d,setItemProperties:U},a)}async function k(e,a){await D(e);const t=e[0].portalItem,r=I(t),n=await Promise.all(e.map((e=>(0,s.Nw)(e,e.isTable?r.forTables:r.forLayers,a)))),i=await P(t,e.map(((e,a)=>({layer:e,layerJSON:n[a]}))));return function(e,a){C(e,a),(0,s.UY)(e)}(t,i),await t.update({data:i}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),(0,o.D)(r.forLayers),(0,o.D)(r.forTables),t.clone()}async function F(e,a,t){return(0,s.po)({layer:e,itemType:f,validateLayer:b,createJSONContext:a=>v(a,e),createItemData:(e,a)=>Promise.resolve(S(e)),errorNamePrefix:m,newItem:a,setItemProperties:Y},t)}async function z(e,a,t){await Z(e);const n=(0,s.uT)({itemType:f,errorNamePrefix:h,newItem:a}),l=I(n),c=await Promise.all(e.map((e=>(0,s.Nw)(e,e.isTable?l.forTables:l.forLayers,t)))),u=await L(e.map(((e,a)=>({layer:e,layerJSON:c[a]}))));await async function(e,a,t){let n=0;for(const{isTable:a}of e)a||n++;const o=e[0].parsedUrl.path,l=(0,i.Qc)(o);if(a.url="FeatureServer"===l?.serverType?l.url.path:o,a.title||=l.title,a.extent=null,n>0){const t=e.map((e=>e.fullExtent)).filter(r.pC).reduce(((e,a)=>e.clone().union(a)));t&&(a.extent=await(0,y.$o)(t))}J(e,a,t),(0,s.UY)(a)}(e,n,u),await(0,s.jX)(n,u,t);for(const a of e)a.portalItem=n.clone();return(0,o.D)(l.forLayers),(0,o.D)(l.forTables),n}},21011:(e,a,t)=>{t.d(a,{DC:()=>u,Nw:()=>h,UY:()=>b,Ym:()=>d,a1:()=>I,jX:()=>v,po:()=>T,uT:()=>m,xG:()=>f});var r=t(70375),n=t(50516),o=t(93968),s=t(53110),i=t(84513),l=t(31370),c=t(60629);function u(e,a,t){const n=t(e);if(!n.isValid)throw new r.Z(`${a}:invalid-parameters`,n.errorMessage,{layer:e})}async function y(e){const{layer:a,errorNamePrefix:t,validateLayer:r}=e;await a.load(),u(a,t,r)}function f(e,a){return`Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${a}`}function p(e){const{item:a,errorNamePrefix:t,layer:n,validateItem:o}=e;if(function(e){const{item:a,itemType:t,additionalItemType:n,errorNamePrefix:o,layer:s}=e,i=[t];if(n&&i.push(n),!i.includes(a.type)){const e=i.map((e=>`'${e}'`)).join(", ");throw new r.Z(`${o}:portal-item-wrong-type`,`Portal item type should be one of: "${e}"`,{item:a,layer:s})}}(e),o){const e=o(a);if(!e.isValid)throw new r.Z(`${t}:invalid-parameters`,e.errorMessage,{layer:n})}}function d(e){const{layer:a,errorNamePrefix:t}=e,{portalItem:n}=a;if(!n)throw new r.Z(`${t}:portal-item-not-set`,f(a,"requires the portalItem property to be set"));if(!n.loaded)throw new r.Z(`${t}:portal-item-not-loaded`,f(a,"cannot be saved to a portal item that does not exist or is inaccessible"));p({...e,item:n})}function m(e){const{newItem:a,itemType:t}=e;let r=s.default.from(a);return r.id&&(r=r.clone(),r.id=null),r.type??=t,r.portal??=o.Z.getDefault(),p({...e,item:r}),r}function w(e){return(0,i.Y)(e,"portal-item")}async function h(e,a,t){"beforeSave"in e&&"function"==typeof e.beforeSave&&await e.beforeSave();const r=e.write({},a);return await Promise.all(a.resources?.pendingOperations??[]),(0,c.z)(a,{errorName:"layer-write:unsupported"},t),r}function b(e){(0,l.qj)(e,l.hz.JSAPI),e.typeKeywords&&(e.typeKeywords=e.typeKeywords.filter(((e,a,t)=>t.indexOf(e)===a)))}async function v(e,a,t){const r=e.portal;await r.signIn(),await r.user.addItem({item:e,data:a,folder:t?.folder})}async function I(e,a){const{layer:t,createItemData:r,createJSONContext:o,setItemProperties:s,saveResources:i,supplementalUnsupportedErrors:l}=e;await y(e),d(e);const c=t.portalItem,u=o?o(c):w(c),f=await h(t,u,{...a,supplementalUnsupportedErrors:l}),p=await r({layer:t,layerJSON:f},c);return await(s?.(t,c,p)),b(c),await c.update({data:p}),(0,n.D)(u),await(i?.(c,u)),c}async function T(e,a){const{layer:t,createItemData:r,createJSONContext:o,setItemProperties:s,saveResources:i,supplementalUnsupportedErrors:l}=e;await y(e);const c=m(e),u=o?o(c):w(c),f=await h(t,u,{...a,supplementalUnsupportedErrors:l}),p=await r({layer:t,layerJSON:f},c);return await s(t,c,p),b(c),await v(c,p,a),t.portalItem=c,(0,n.D)(u),await(i?.(c,u)),c}},8308:(e,a,t)=>{t.d(a,{V:()=>o,W:()=>f});var r=t(40371);const n=new Set(["Catalog Layer","Feature Layer","Oriented Imagery Layer"]);async function o(e,a){const{loadContext:t,...n}=a||{},o=t?await t.fetchServiceMetadata(e,n):await(0,r.T)(e,n);y(o),l(o);const s={serviceJSON:o};if((o.currentVersion??0)<10.5)return s;const i=`${e}/layers`,c=t?await t.fetchServiceMetadata(i,n):await(0,r.T)(i,n);return y(c),l(c),s.layersJSON={layers:c.layers,tables:c.tables},s}function s(e){const{type:a}=e;return!!a&&n.has(a)}function i(e){return"Table"===e.type}function l(e){e.layers=e.layers?.filter(s),e.tables=e.tables?.filter(i)}function c(e){e.type||="Feature Layer"}function u(e){e.type||="Table"}function y(e){e.layers?.forEach(c),e.tables?.forEach(u)}function f(e){switch(e){case"Feature Layer":case"Table":return"FeatureLayer";case"Oriented Imagery Layer":return"OrientedImageryLayer";case"Catalog Layer":return"CatalogLayer"}return"FeatureLayer"}},40371:(e,a,t)=>{t.d(a,{T:()=>n});var r=t(66341);async function n(e,a){const{data:t}=await(0,r.Z)(e,{responseType:"json",query:{f:"json",...a?.customParameters,token:a?.apiKey}});return t}}}]);