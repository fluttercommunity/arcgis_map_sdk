"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[18152,47239,48687],{54266:(t,e,i)=>{i.d(e,{D:()=>x});var n=i(36663),s=i(73479),a=i(21990),r=i(26166),o=i(29778),m=i(93758),h=i(42379);function _(){return{outPoint:new o.P,index:-1,t:Number.NaN}}function u(t,e,i){return{outPoint:t.clone(),index:e,t:i}}function c(t,e,i,n){t.outPoint.assign(e),t.index=i,t.t=n}function l(t,e){t.outPoint.assign(e.outPoint),t.index=e.index,t.t=e.t}function p(t,e,i,n){t.index=i,t.t=n,e.queryCoord2D(t.t,t.outPoint)}function g(t,e){const i=_();l(i,t),l(t,e),l(e,i)}function y(t,e,i,n,a,o){if(t.getGeometryType()===s.G.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const e=n.nextSegment();if(0!==(0,r.i)(t,e.getEndXY(),0))return c(a,e.getEndXY(),-1,Number.NaN),c(o,e.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===s.G.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const t=i.nextSegment();if(0!==(0,r.i)(e,t.getEndXY(),0))return c(a,t.getEndXY(),-1,Number.NaN),c(o,t.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}return!1}function d(t,e){return!!Number.isNaN(e)||t<=e}function P(t){const e=new a.a;return e.addEnvelope(t,!1),e}class x{constructor(t,e){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=e,this.m_maxSqrDistance=t*t,this.m_maxDistance=t,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=t,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let t=Math.sqrt(this.m_maxSqrDistance);for(;t<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,t=Math.sqrt(this.m_maxSqrDistance)}}calculate(t,e,i,n){if((t.getGeometryType()!==h.P.type||e.getGeometryType()!==h.P.type)&&(this.m_env2DgeometryA=new m.j,this.m_env2DgeometryB=new m.j,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!d(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const s=u(new o.P,(0,o.j)(),Number.NaN),a=u(new o.P,(0,o.j)(),Number.NaN),r=this._ExecuteBruteForce(t,e,s,a);return d(r,this.m_maxDistance)?(null!==i&&l(i,s),null!==n&&l(n,a),r):Number.POSITIVE_INFINITY}isNear(t,e){if(this.m_bIsNearCalc=!0,t.isEmpty()||e.isEmpty())return!1;if(t===e)return!0;let i=!0;if(t.getGeometryType()!==h.P.type&&t.getGeometryType()!==h.E.type||e.getGeometryType()!==h.P.type&&e.getGeometryType()!==h.E.type||(i=!1),i){if(this.m_env2DgeometryA=new m.j,this.m_env2DgeometryB=new m.j,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const n=u(new o.P,(0,o.j)(),Number.NaN),s=u(new o.P,(0,o.j)(),Number.NaN);return this._ExecuteBruteForce(t,e,n,s)<=this.m_maxDistance}progress_(t=!1){}_ExecuteBruteForce(t,e,i,n){switch(t.getGeometryType()){case s.G.enumPoint:return this.distancePointGeometry(t,e,i,n);case s.G.enumMultiPoint:return this.distanceMultipointGeometry(t,e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeGeometry(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathGeometry(t,e,i,n);default:return Number.NaN}}distancePointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointPoint(t,e,i,n);case s.G.enumMultiPoint:return this.distancePointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distancePointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distancePointEnvelope(t,e,i,n);default:return Number.NaN}}distancePointPoint(t,e,i,n){const s=t.getXY(),a=e.getXY();return c(i,s,0,0),c(n,a,0,0),Math.sqrt(o.P.sqrDistance(s,a))}distancePointMultipoint(t,e,i,n){const s=t.getXY();let a=this.m_maxSqrDistance,r=a,m=!1;const h=e.getPointCount(),_=new o.P;for(let t=0;t<h;++t)if(e.queryXY(t,_),r=o.P.sqrDistance(s,_),this.m_bIsNearCalc){if(r<=a)return 0}else if(!(r>a)&&(!m&&r===a||r<a)&&(a=r,c(i,s,0,0),c(n,_,t,0),m=!0,0===a))return 0;return m?Math.sqrt(a):Number.POSITIVE_INFINITY}distancePointMultipath(t,e,i,n){const a=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),h=t.getXY();if(!a&&e.getGeometryType()===s.G.enumPolygon&&0!==(0,r.i)(e,h,0))return c(i,h,0,0),c(n,h,-1,Number.NaN),0;e.getImpl().getAccelerators();let _=this.m_maxSqrDistance,u=_,l=-1;const p=new m.j,g=e.querySegmentIterator();let y=!1;for(;g.nextPath();)for(;g.hasNextSegment();){const t=g.nextSegment();t.queryEnvelope(p);const e=p.sqrDistance(h);if(e>_)continue;if(!this.m_bIsNearCalc&&y&&e===_)continue;l=t.getClosestCoordinate(h,!1);const s=t.getCoord2D(l);if(u=o.P.sqrDistance(h,s),this.m_bIsNearCalc){if(u<=_)return 0}else if(!(u>_)&&(!y||u<_)&&(_=u,c(i,h,0,0),c(n,s,g.getStartPointIndex(),l),y=!0,0===_))return 0}return y?Math.sqrt(_):Number.POSITIVE_INFINITY}distancePointEnvelope(t,e,i,n){const s=t.getXY();c(i,s,0,0),c(n,s,-1,Number.NaN);const a=e.asEnvelope2D();return a.contains(s)?0:Math.sqrt(a.sqrDistance(s,n.outPoint))}distanceMultipointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipoint(e,t,n,i);return this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:return this.distanceMultipointMultipoint(t,e,i,n,1,1);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipointMultipath(t,P(e),i,n);default:return Number.NaN}}distanceMultipointMultipoint(t,e,i,s,a,r){const m={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&1===a&&1===r){const n=Math.trunc((0,o.c)(Math.sqrt(t.getPointCount())+1,1,(0,o.i)())),a=Math.trunc((0,o.c)(Math.sqrt(e.getPointCount())+1,1,(0,o.i)()));if((n>=4||a>=4)&&this.distanceMultipointMultipoint(t,e,i,s,n,a)<=this.m_maxSqrDistance)return 0}let h=this.m_maxSqrDistance;const _=[t],u=[e],l=this.swapGeometriesIfBGtA(_,u);l&&(this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r=(0,o.b)(a,a=r),g(i,s)),(0,n.b)(m,(0,o.h)((()=>{g(i,s),this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)}),!l),!1);const p=_[0].getImpl(),y=u[0].getImpl(),d=p.getPointCount(),P=y.getPointCount(),x=P>1;let f=!1;const S=new o.P,E=new o.P;for(let t=0;t<d;t+=a){if(p.queryXY(t,S),x){const t=this.m_env2DgeometryB.sqrDistance(S);if(this.m_bIsNearCalc){if(t>h)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(S)<=h)return 0}else if(t>=h)continue}for(let e=0;e<P;e+=r){y.queryXY(e,E);const n=o.P.sqrDistance(S,E);if(this.m_bIsNearCalc){if(n<=h)return 0}else if(!(n>h||f&&n===h)&&(!f||n<h)&&(c(i,S,t,0),c(s,E,e,0),f=!0,h=n,0===h))return f?Math.sqrt(h):Number.POSITIVE_INFINITY}}return f?Math.sqrt(h):Number.POSITIVE_INFINITY}catch(t){m.error=t,m.hasError=!0}finally{(0,n.c)(m)}}distanceMultipointMultipath(t,e,i,n){let a=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&e.getGeometryType()===s.G.enumPolygon;const h=e.querySegmentIterator();h.stripAttributes();const _=new m.j,u=new o.P;let l=this.m_maxSqrDistance;const p=t.getImpl(),g=p.getPointCount(),y=g>1;let d=!1;for(;h.nextPath();)for(;h.hasNextSegment();){const t=h.nextSegment();if(t.queryLooseEnvelope(_),y){const t=_.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l||d&&t===l)continue}for(let s=0;s<g;s++){if(p.queryXY(s,u),a&&0!==(0,r.i)(e,u,0))return c(i,u,-1,Number.NaN),c(n,u,s,0),0;{const t=_.sqrDistance(u);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l)continue}const o=t.getClosestCoordinate(u,!1),m=t.getCoord2D(o);u.subThis(m);const g=u.sqrLength();if(this.m_bIsNearCalc){if(g<=l)return 0}else if(!(g>l)&&(!d||g<l)&&(l=g,c(i,p.getXY(s),s,0),c(n,m,h.getStartPointIndex(),o),d=!0,0===l))return 0}a=!1}return d?Math.sqrt(l):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointEnvelope(e,t,n,i);case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,P(t),n,i);return this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(P(t),e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeEnvelope(t,e,i,n);default:return Number.NaN}}distanceEnvelopeEnvelope(t,e,i,n){i.t=Number.NaN,i.index=-1,n.t=Number.NaN,n.index=-1;const s=t.asEnvelope2D(),a=e.asEnvelope2D();return Math.sqrt(s.sqrDistanceEnvelope(a,i.outPoint,n.outPoint))}distanceMultipathGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipathMultipath(t,P(e),i,n);default:return Number.NaN}}distanceMultipathMultipath(t,e,i,s){const r={stack:[],error:void 0,hasError:!1};try{const h=[t],u=[e],c=this.swapGeometriesIfAGtB(h,u);c&&(this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),g(i,s)),(0,n.b)(r,(0,o.h)((()=>{g(i,s),this.m_env2DgeometryB=(0,o.b)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)}),!c),!1);const d=h[0],P=u[0],x=d.querySegmentIterator();x.stripAttributes();const f=P.querySegmentIterator();if(f.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const t=Math.trunc((0,o.c)(Math.sqrt(d.getPointCount())+1,1,(0,o.i)())),e=Math.trunc((0,o.c)(Math.sqrt(d.getPointCount())+1,1,(0,o.i)()));if(this.distanceMultipointMultipoint(d,P,i,s,t,e)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const t=_(),e=_();if(y(d,P,x,f,t,e))return l(i,t),l(s,e),0}const S=function(t){const e=t.getPathCount(),i=(0,o.d)(t.getSegmentCount(),0);let n=0;for(let s=0;s<e;++s){const e=n+t.getSegmentCountPath(s);for(let a=n,r=t.getPathStart(s);a<e;++a,++r)i[a]=r;n=e}return(0,a.s)(t.getPointCount(),i),i}(d),E=[],M=new a.S,v=new m.j,D=new m.j,T=new m.j;let G=this.m_maxSqrDistance,b=!0,w=!1;for(let t=0,e=S.length;t<e;++t){d.querySegment(S[t],M,!0);const e=M.get();if(e.queryEnvelope(v),!(v.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>G)){if(this.m_bIsNearCalc&&v.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=G)return 0;for(;f.nextPath();){if(this.progress_(),b)P.queryPathEnvelope(f.getPathIndex(),T),E[f.getPathIndex()]=T.clone();else if(v.sqrDistanceEnvelope(E[f.getPathIndex()],null,null)>G)continue;for(;f.hasNextSegment();){const n=f.nextSegment();if(n.queryEnvelope(D),v.sqrDistanceEnvelope(D,null,null)<=G){const a=!v.isIntersecting(D),r=[0],o=[0];let m=e.distance(n,a,r,o);if(m*=m,this.m_bIsNearCalc&&m<=this.m_maxSqrDistance)return 0;if(m<G||m===G&&S[t]<i.index){if(w=!0,p(i,e,S[t],r[0]),p(s,n,f.getStartPointIndex(),o[0]),0===m)return 0;G=m}}}}f.resetToFirstPath(),b=!1}}return w?Math.sqrt(G):Number.POSITIVE_INFINITY}catch(t){r.error=t,r.hasError=!0}finally{(0,n.c)(r)}}swapGeometriesIfAGtB(t,e){return(0,s.v)(t[0])>(0,s.v)(e[0])&&(e[0]=(0,o.b)(t[0],t[0]=e[0]),!0)}swapGeometriesIfBGtA(t,e){return this.swapGeometriesIfAGtB(e,t)}}},18152:(e,k,X)=>{X.r(k),X.d(k,{OperatorGeodeticArea:()=>Mt});var U=X(73479),$=X(21990),j=X(66886),Q=X(26166),J=X(29778),Z=X(93758),K=X(42379),tt=X(66162),et=X(79124),it=X(36663),nt=X(32774);X(54266),X(48687),X(47239);class st{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,i){this.m_peR1=new l,this.m_peR2=new l,this.m_peR3=new l,void 0!==t?this.reset(t,e,i):this.reset(1,0,1)}reset(t,e,i){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,i,n){const s=this.m_peR1,a=this.m_peR2,r=this.m_peR3;_.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,i*this.m_unitToRad,n*this.m_unitToRad,r,s,a,0);const o=Math.cos(s.val),m=Math.cos(a.val+3.141592653589793),h=e*this.m_unitToRad,u=G.phiToEta(this.m_e2,h),c=Math.sin(s.val)*Math.cos(u);let l=e;if(o*m<0){const t=o<0?-1:1,e=Math.acos(Math.abs(c))*t;G.etaToPhi(this.m_e2,e)/this.m_unitToRad}let p=I((i-t)*this.m_unitToRad,2*Math.PI);Math.abs(p)>Math.PI&&(p>0?p-2*Math.PI:p+2*Math.PI),this.m_unitToRad,t+p;const g=new w;return g.xmin=Math.min(t,i),g.xmax=Math.max(t,i),g.ymin=Math.min(e,n),g.ymin=Math.min(g.ymin,l),g.ymax=Math.max(e,n),g.ymax=Math.max(g.ymax,l),g}minDistanceGeodesic(t,e){const i=O(t),n=O(e);if(i&&n)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const s=this.normalizeGeodesic_(e,t);return function(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}(t,s)?t.ymin>=s.ymax?this.minDistanceGeodesicUpDown_(t,s):s.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(s,t):t.xmin>s.xmax?this.minDistanceGeodesicLeftRight_(s,t):this.minDistanceGeodesicLeftRight_(t,s):0}normalizeGeodesic_(t,e){const i=t.clone(),n=t.clone();let s=V(i,e);if(0===s)return i;for(;n.xmax>e.xmin;){n.xmin-=this.m_u360,n.xmax-=this.m_u360;const t=V(n,e);if(t<s&&(i.assign(n),t,0===s))return i}for(n.assign(t);n.xmin<e.xmax;){n.xmin+=this.m_u360,n.xmax+=this.m_u360;const t=V(n,e);if(t<s&&(i.assign(n),t,0===s))return i}return i}lowerDistanceGeodetic_(t,e,i,n){const s=this.m_peR1;{const a=this.m_b*this.m_b/this.m_a,r=G.phiToPhig(this.m_e2,this.m_unitToRad*e),o=G.phiToPhig(this.m_e2,this.m_unitToRad*n);_.geodeticDistance(a,0,this.m_unitToRad*t,r,this.m_unitToRad*i,o,s,null,null,0)}return s.val}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(i,n)}{const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(i,n)}}minDistanceGeodesicLeftRight_(t,e){let i=Math.abs(t.xmax-e.xmin);for(;i>this.m_u180;)this.m_u360;let n=Math.abs(t.xmin-e.xmax);for(;n>this.m_u180;)this.m_u360;return Math.abs(i)<=Math.abs(n)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let i,n;return this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),Math.min(i,n)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),Math.min(i,n)),this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),Math.min(i,n),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),Math.min(i,n)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),Math.min(i,n)),i}lowerDistanceGeodeticSegMeridional_(t,e,i,n,s,a){let r=this.lowerDistanceGeodeticPtMeridional_(t,e,n,s,a);const o=this.lowerDistanceGeodeticPtMeridional_(t,i,n,s,a);let m=this.lowerDistanceGeodeticPtMeridional_(n,s,t,e,i);const h=this.lowerDistanceGeodeticPtMeridional_(n,a,t,e,i);return Math.min(r,o),Math.min(m,h),Math.min(r,m)}lowerDistanceGeodeticPtMeridional_(t,e,i,n,s){const a=this.m_b*this.m_b/this.m_a,r=G.phiToPhig(this.m_e2,this.m_unitToRad*e),o=G.phiToPhig(this.m_e2,this.m_unitToRad*n),m=G.phiToPhig(this.m_e2,this.m_unitToRad*s),h=this.m_peR1,u=this.m_peR2;_.geodeticDistance(a,0,this.m_unitToRad*i,o,this.m_unitToRad*t,r,h,null,null,0),_.geodeticDistance(a,0,this.m_unitToRad*i,m,this.m_unitToRad*t,r,u,null,null,0);const c=p(1,0,new M(this.m_unitToRad*t,r)),l=p(1,0,new M(this.m_unitToRad*i,o)),g=p(1,0,new M(this.m_unitToRad*i,m));let y=new T;y.setCrossProductVector(l,g);const d=l.dotProduct(g);if(y.length()<1.568e-10)return d>=0?Math.min(h.val,u.val):0;y.getUnitVector();let P=new T;if(P.setCrossProductVector(y,c),P.length()<1.568e-10)return Math.min(h.val,u.val)-1e-5*a;P.getUnitVector();let x=c.sub(y.mul(c.dotProduct(y)));{const e=new T;e.setCrossProductVector(l,x);const i=new T;i.setCrossProductVector(x,g);let n=y.dotProduct(e)>0&&y.dotProduct(i)>0;if(n||(x.negateThis(),e.setCrossProductVector(l,x),i.setCrossProductVector(x,g),y.dotProduct(e)>0&&y.dotProduct(i)>0),n){x.getUnitVector();const e=D(1,0,x),i=this.m_peR3;_.geodeticDistance(a,0,this.m_unitToRad*t,r,e.x,e.y,i,null,null,0);const n=Math.min(h.val,u.val);return Math.min(n,i.val)}}return Math.min(h.val,u.val)}}class at{constructor(t,e,i,n,s=0,a=4){this.m_ptDistFrom=new J.P,this.m_segStartPt=new J.P,this.m_segEndPt=new J.P,this.m_geodeticLength=new Q.E,this.m_az12=new Q.E,this.m_minGeodeticDist=new Q.E,this.m_segStartPt3d=new K.h,this.m_segEndPt3d=new K.h,this.m_sr=n,this.m_distCurveType=s,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const r=(0,Q.G)();this.m_inputGCS.querySpheroidData(r),this.m_a=r.majorSemiAxis,this.m_eSquared=r.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,i)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign((0,Q.Q)(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign((0,Q.Q)(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return t=>{let e;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const n=(0,it.b)(i,new Q.E,!1),s=(0,it.b)(i,new Q.E,!1);Q.F.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*t,this.m_az12.val,n,s,this.m_segCurveType),e=new J.P(n.val,s.val);break}catch(t){i.error=t,i.hasError=!0}finally{(0,it.c)(i)}}case 2:{const i=K.h.lerp(this.m_segStartPt3d,this.m_segEndPt3d,t);e=(0,Q.Y)(this.m_a,this.m_eSquared,i);break}case 4:e=J.P.lerp(this.m_segStartPt,this.m_segEndPt,t),this.m_bIsPannablePcs&&((0,Q.S)(this.m_sr,0,[e],1),e.mulThis(this.m_rpu));break;default:(0,U.c)("Invalid curve type")}return Q.F.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,e.x,e.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:Q.F.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=J.P.distance(this.m_segStartPt,this.m_segEndPt);break;default:(0,U.c)("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}class rt{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,i,n,s){this.m_boxGeomA=H(),this.m_boxGeomB=H(),this.m_envGeomA=new w,this.m_envGeomB=new w,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new B,this.m_scaleToDegrees=new B,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=i,this.m_maxDistance=n,this.m_maxDeviation=s,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const a=v();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new st(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,i,n){const s=L(),a=L();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,s,a))return i&&z(i,s),n&&z(n,a),0;const r=this.prepareGeometry(t);if(r.isEmpty())return Number.NaN;const o=this.prepareGeometry(e);if(o.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(r,o);const m=this._ExecuteBruteForce(r,o,s,a);return m>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(s),z(i,s)),n&&(this.prepareOutput(a),z(n,a)),m)}createDistanceFunctor(t,e,i){const n=new at(t,e,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||n.setSegmentCurveType(2),n}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(new c).foldInto360Range(t,this.m_inputSR),2===this.m_inputSR.getCoordinateSystemType()){const e=h(this.m_inputSR,this.m_inputGCS,null);(new c).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,n,a){switch(t.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,n,a);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,n,a);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,n,a);default:i("")}}calculateDistanceGeodeticPointGeometry(t,e,n,a){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,n,a);case s.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,n,a);case s.enumPolyline:case s.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,n,a);default:i("")}}calculateDistanceGeodeticPointPoint(e,i,n,s){const a={stack:[],error:void 0,hasError:!1};try{const r=e.getXY();r.scale(this.m_rpu);const o=i.getXY();o.scale(this.m_rpu),n.outPoint.assign(r),s.outPoint.assign(o);const m=t(a,new l,!1);return _.geodeticDistance(this.m_a,this.m_eSquared,r.x,r.y,o.x,o.y,m,null,null,this.m_distCurveType),m.val}catch(t){a.error=t,a.hasError=!0}finally{r(a)}}calculateDistanceGeodeticPointMultipoint(e,i,n,s){const a={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(e,i);const r=this.estimateMinimumDistance(n,s);let o=r<this.m_maxDistance?r:this.m_maxDistance;const m=e.getXY();m.scale(this.m_rpu),n.outPoint.assign(m);const h=p(this.m_a,this.m_eSquared,m),u=new M,c=i.getImpl(),g=t(a,new l,!1),y=c.getPointCount();for(let t=0;t<y;++t){c.queryXY(t,u),u.scale(this.m_rpu);const e=p(this.m_a,this.m_eSquared,u);if(!(T.distance(h,e)>o)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>o)&&(_.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,u.x,u.y,g,null,null,this.m_distCurveType),g.val<o&&(g.val,s.outPoint=u,0===o)))return o}return o===this.m_maxDistance?Number.POSITIVE_INFINITY:o}catch(t){a.error=t,a.hasError=!0}finally{r(a)}}calculateDistanceGeodeticPointMultipath(e,i,s,a){const r={stack:[],error:void 0,hasError:!1};try{const o=new M,m=new M;o.assign(e.getXY()),m.assign(e.getXY()),s.outPoint.assign(m.mul(this.m_rpu)),this.m_bIsPannablePcs&&d(this.m_inputSR,[o],1,!1),this.computeEnvelopesAndBoxes(e,i);const h=this.estimateMinimumDistance(s,a);let _=h<this.m_maxDistance?h:this.m_maxDistance;const u=i.getImpl(),c=new M(0,0),l=new M(0,0),p=[1],g=this.canUseSpatialTree(e,i),y=W();g&&this.buildSpatialTree(y,i);const P=H();P.setCoords({xmin:m.x,ymin:m.y,xmax:m.x,ymax:m.y});const x=t(r,this.createDistanceFunctor(m,c,l),!1),f=u.querySegmentIterator();if(f.stripAttributes(),g)n(0);else for(;f.nextPath();)for(;f.hasNextSegment();){const t=f.nextSegment(),e=this.findOrComputeBoxSegment(f.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(P,e)>_)continue;const i=this.calculateDistanceGeodeticPointSegment(o,m,t,p,x);if(i.second<_&&(this.updateOutputSegment(a,t,i.first),i.second,0===_))return 0}return _===this.m_maxDistance?Number.POSITIVE_INFINITY:_}catch(t){r.error=t,r.hasError=!0}finally{o(r)}}calculateDistanceGeodeticMultipointGeometry(t,e,n,a){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,a,n);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,n,a);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,n,a);default:i("")}}calculateDistanceGeodeticMultipointMultipoint(e,i,n,s){const a={stack:[],error:void 0,hasError:!1};try{const r=t(a,new l,!1);this.computeEnvelopesAndBoxes(e,i);const o=this.estimateMinimumDistance(n,s);let m=o<this.m_maxDistance?o:this.m_maxDistance;const h=new M,u=new M,c=e.getImpl(),g=i.getImpl(),y=H(),d=c.getPointCount(),P=g.getPointCount();for(let t=0;t<d;++t){if(h.assign(c.getXY(t)),y.setCoords({xmin:h.x,ymin:h.y,xmax:h.x,ymax:h.y}),this.m_envHelper.minDistanceGeodesic(y,this.m_boxGeomB)>m)continue;h.scale(this.m_rpu);const e=p(this.m_a,this.m_eSquared,h);for(let t=0;t<P;++t){u.assign(g.getXY(t)),u.scale(this.m_rpu);const i=p(this.m_a,this.m_eSquared,u);if(!(T.distance(e,i)>=m)&&(_.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,u.x,u.y,r,null,null,this.m_distCurveType),r.val<m&&(n.outPoint.assign(h),s.outPoint.assign(u),r.val,0===m)))return m}}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(t){a.error=t,a.hasError=!0}finally{r(a)}}calculateDistanceGeodeticMultipointMultipath(e,i,s,a){const r={stack:[],error:void 0,hasError:!1};try{const o=i.getImpl().querySegmentIterator();o.stripAttributes(),this.computeEnvelopesAndBoxes(e,i);const m=this.estimateMinimumDistance(s,a);let h=m<this.m_maxDistance?m:this.m_maxDistance;const _=new M,u=new M(0,0),c=new M(0,0),l=new M(0,0),p=[0],g=H(),y=t(r,this.createDistanceFunctor(u,c,l),!1),P=W(),x=this.canUseSpatialTree(e,i);x&&this.buildSpatialTree(P,i);const f=e.getPointCount();for(let t=0;t<f;++t)if(_.assign(e.getXY(t)),u.assign(e.getXY(t)),this.m_bIsPannablePcs&&d(this.m_inputSR,[_],1,!1),g.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),!(this.m_envHelper.minDistanceGeodesic(g,this.m_boxGeomB)>h))if(y.setPointDistFrom(u),x)n(0);else{for(;o.nextPath();)for(;o.hasNextSegment();){const t=o.nextSegment();if(this.m_envHelper.minDistanceGeodesic(g,this.findOrComputeBoxSegment(o.getStartPointIndex(),t,this.m_segmentBoxesB))>h)continue;const e=this.calculateDistanceGeodeticPointSegment(_,u,t,p,y);if(e.second<h&&(s.outPoint.assign(u.mul(this.m_rpu)),this.updateOutputSegment(a,t,e.first),e.second,0===h))return 0}o.resetToFirstPath()}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){r.error=t,r.hasError=!0}finally{o(r)}}calculateDistanceGeodeticMultipathGeometry(t,e,n,a){switch(e.getGeometryType()){case s.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,a,n);case s.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,a,n);case s.enumPolyline:case s.enumPolygon:case s.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,n,a);default:i("")}}calculateDistanceGeodeticMultipathMultipath(t,e,i,n){const s=[t],a=[e],r=this.swapGeometries(s,a),o=s[0],m=a[0];this.computeEnvelopesAndBoxes(s[0],a[0]);const h=this.estimateMinimumDistance(i,n),_=this.calculateDistanceGeodeticMultipathMultipath_(o,m,i,n,h);return r&&(n.outPoint=E(i.outPoint,i.outPoint=n.outPoint)),_}calculateDistanceGeodeticMultipathMultipath_(e,i,s,a,o=Number.MAX_VALUE){const m={stack:[],error:void 0,hasError:!1};try{let h=o;const _=new M(0,0),u=new M,c=new M(0,0),l=new M,p=new M(0,0),y=new M,d=new M,P=new M,f=[new M],S=[0],E=[0],v=H(),D=H(),T=t(m,this.createDistanceFunctor(p,_,c),!1),G=W(),b=this.canUseSpatialTree(e,i);b&&this.buildSpatialTree(G,i);const w=i.querySegmentIterator();w.stripAttributes();const N=new r,C=A(e);for(let t=0;t<C.length;++t){const i=C[t];e.getSegmentBuffer(i,N,!0);const r=N.get();if(v.assign(this.findOrComputeBoxSegment(i,r,this.m_segmentBoxesA)),b)n(0);else{if(p.assign(r.getStartXY()),y.assign(r.getStartXY()),d.assign(r.getEndXY()),P.assign(r.getEndXY()),this.m_bIsPannablePcs&&(g(this.m_inputSR,0,[y],1),g(this.m_inputSR,0,[P],1)),this.m_envHelper.minDistanceGeodesic(v,this.m_boxGeomB)>h)continue;for(;w.nextPath();){for(;w.hasNextSegment();){const t=w.nextSegment();if(_.assign(t.getStartXY()),u.assign(t.getStartXY()),c.assign(t.getEndXY()),l.assign(t.getEndXY()),r.intersect(t,f,S,E,this.m_tolerance))return this.updateOutputSegment(s,r,S[0]),this.updateOutputSegment(a,t,E[0]),0;if(this.m_bIsPannablePcs&&(g(this.m_inputSR,0,[u],1),g(this.m_inputSR,0,[l],1)),D.assign(this.findOrComputeBoxPoint(w.getStartPointIndex(),u,l,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(v,D)>h)continue;T.setSegmentEndPoints(_,c),T.setPointDistFrom(y);let e=x(T.makeFunctor(),0,1,1e-10);if(e.second<h&&(s.outPoint.assign(y.mul(this.m_rpu)),this.updateOutputSegment(a,t,e.first),e.second,0===h))break;if(T.setPointDistFrom(P),x(T.makeFunctor(),0,1,1e-10),e.second<h&&(s.outPoint.assign(P.mul(this.m_rpu)),this.updateOutputSegment(a,t,e.first),e.second,0===h))break;if(T.setSegmentEndPoints(p,d),T.setPointDistFrom(u),x(T.makeFunctor(),0,1,1e-10),e.second<h&&(this.updateOutputSegment(s,r,e.first),a.outPoint.assign(u.mul(this.m_rpu)),e.second,0===h))break;if(T.setPointDistFrom(l),x(T.makeFunctor(),0,1,1e-10),e.second<h&&(this.updateOutputSegment(s,r,e.first),a.outPoint.assign(l.mul(this.m_rpu)),e.second,0===h))break}if(0===h)return 0}w.resetToFirstPath()}}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){m.error=t,m.hasError=!0}finally{h(m)}}calculateDistanceGeodeticPointSegment(t,e,i,n,s){const a=i.getStartXY(),r=i.getEndXY();return i.intersectPoint(t,n,this.m_tolerance)?R(n[0],0):(s.setPointDistFrom(e),s.setSegmentEndPoints(a,r),x(s.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const i=t.getGeometryType();if(i===s.enumPoint||i===s.enumMultiPoint)return this._NormalizeAndProject(e);if(i===s.enumEnvelope&&this.envelopeToPolygon(e),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if(y(e,this.m_inputSR,0,null),e.isEmpty())return e;(new F).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new c).execute(e,t,this.m_progressTracker)}const n=new w;e.queryLooseEnvelope(n);const a=this.m_inputSR.getPannableExtent();if(n.ymin<a.ymin||n.ymax>a.ymax){const t=new w(n.xmin-1,a.ymin,n.xmax+1,a.ymax);if((new Y).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return n.width()>2*a.width()?(P(e,-2*a.width(),2*a.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const i=new w;t.queryEnvelope(i);const n=this.m_inputSR.getPannableExtent();if(n.containsEnvelope(i))return t;const s=new C;n.queryIntervalX(s);const a=new C;return i.queryIntervalX(a),s.contains(a)?S(t,this.m_inputSR):(new c).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&d(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,i){e.queryCoord2D(i,t.outPoint),this.m_bIsPannablePcs&&g(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const i=new w(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),b(null,i)}envelopeToPolygon(t){const e=new u;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,i){switch(t.getGeometryType()){case s.enumPoint:return this.computeBoxPoint(t,e);case s.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case s.enumPolyline:case s.enumPolygon:return this.computeBoxMultiPath(t,e,i);default:o("Invalid geometry type")}}computeBoxPoint(t,e){const i=t.getXY();e.length=0,e.push(i.mul(this.m_rpu));const n=H();return n.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),n}computeBoxMultiPoint(t,e){let i=!0;for(let n=0;n<t.getPointCount();++n){const s=t.getXY(n);if(i){e.length=0;for(let t=0;t<4;++t)e.push(s.clone());!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);const n=H();return t.queryEnvelope(n),n}computeBoxMultiPath(t,e,i){let n=!0;const s=H();s.setEmpty();const a=t.querySegmentIterator();for(a.stripAttributes();a.nextPath();)for(;a.hasNextSegment();){const t=a.nextSegment(),r=t.getStartXY(),o=t.getEndXY();if(this.m_bIsPannablePcs&&(g(this.m_inputSR,0,[r],1),g(this.m_inputSR,0,[o],1)),n){for(let t=0;t<4;++t)e.push(r.clone());!1}r.x<e[0].x&&e[0].assign(r),r.y>e[1].y&&e[1].assign(r),r.x>e[2].x&&e[2].assign(r),r.y<e[3].y&&e[3].assign(r),o.x<e[0].x&&e[0].assign(o),o.y>e[1].y&&e[1].assign(o),o.x>e[2].x&&e[2].assign(o),o.y<e[3].y&&e[3].assign(o);const m=this.findOrComputeBoxPoint(a.getStartPointIndex(),r,o,i);s.mergeEnvelope2D(m)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);return s}findOrComputeBoxSegment(t,e,i){if(!i.has(t)){let n=H();if(e.queryEnvelope(n),this.m_bIsPannablePcs){const t=M.construct(n.xmin,n.ymin),e=M.construct(n.xmax,n.ymax);g(this.m_inputSR,0,[t],1),g(this.m_inputSR,0,[e],1),this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return i.set(t,n),n}return i.get(t)}findOrComputeBoxPoint(t,e,i,n){if(!n.has(t)){let s=H();return s.setCoords({xmin:e.x,ymin:e.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&this.m_envHelper.calculateBbox(s.xmin,s.ymin,s.xmax,s.ymax),n.set(t,s),s}return n.get(t)}estimateMinimumDistance(e,i){const n={stack:[],error:void 0,hasError:!1};try{const s=t=>p(this.m_a,this.m_eSquared,t),a=this.m_boundaryPtsA.map(s),r=this.m_boundaryPtsB.map(s);let o=Number.MAX_VALUE,m=0,h=0;for(let t=0;t<a.length;++t)for(let e=0;e<r.length;++e){const i=T.distance(a[t],r[e]);i<o&&(i,t,e)}e.outPoint.assign(this.m_boundaryPtsA[m]),i.outPoint.assign(this.m_boundaryPtsB[h]);const u=t(n,new l,!1);return _.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[m].x,this.m_boundaryPtsA[m].y,this.m_boundaryPtsB[h].x,this.m_boundaryPtsB[h].y,u,null,null,this.m_distCurveType),u.val}catch(t){n.error=t,n.hasError=!0}finally{s(n)}}swapGeometries(t,e){return a(t[0])>a(e[0])&&(e[0]=E(t[0],t[0]=e[0]),this.m_envGeomB=E(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,i,n){let a=t.getGeometryType(),r=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(a===s.enumPoint&&2===e.getDimension()){const s=[0],a=[t.getXY()];if(f(e,a,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(a[0]),n.outPoint.assign(a[0]),!0}else if(r===s.enumPoint&&2===t.getDimension()){const s=[2],a=[e.getXY()];if(f(t,a,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(a[0]),n.outPoint.assign(a[0]),!0}if(a===s.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,i,n);if(r===s.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,n,i);let o,h,_=t,u=e;if(a===s.enumEnvelope&&(this.envelopeToPolygon(t),o,s.enumPolygon),r===s.enumEnvelope&&(this.envelopeToPolygon(e),h,s.enumPolygon),m(a)&&m(r)){const t=_.querySegmentIterator(),e=u.querySegmentIterator(),s=N(),a=N();if(q(_,u,t,e,s,a))return i.outPoint.assign(s.outPoint),n.outPoint.assign(s.outPoint),!0}}return!1}multipointIntersectsArea(t,e,i,n){const s=t.getPointCount();for(let a=0;a<s;++a){const s=[2],r=t.getXY(a);if(f(e,[r],1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(r),n.outPoint.assign(r),!0}return!1}getNearestNeighbourVisitor(t,e,i,s,a,r,o){return n(0),{}}buildSpatialTree(t,e){n(0)}}class ot{constructor(t,e,i,n,s=100){this.m_startPt=t.clone(),this.m_endPt=e.clone(),this.m_cE2=n,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=i.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===i.getCoordinateSystemType(),this.PEProjcs=i.getPECoordSys(),this.m_points=(0,J.d)(2*s,Number.NaN)}setSegmentEndPoints(t,e){this.m_startPt.assign(t),this.m_endPt.assign(e)}makeFunctor(){return t=>{const e=[0,0];e[0]=this.m_startPt.x*(1-t)+this.m_endPt.x*t,e[1]=this.m_startPt.y*(1-t)+this.m_endPt.y*t,this.isPcs&&Q.Z.projToGeogCenter(this.PEProjcs,1,e,0);const i=Math.sin(e[1]*this.m_cRpu);return 0===this.m_cE2?i:-Math.log((1-this.m_cE*i)/(1+this.m_cE*i))*this.m_c1By2e+i/(1-this.m_cE2*i*i)}}}function mt(t,e,i,n,s){const a=function(t,e,i){const n=t.calculateLength2D(),s=(new et.O).execute(t,e,i)/25e3,a=n/t.getSegmentCount()*2;let r=Math.min(a,n/s);return 0===r&&(r=1),(0,J.n)(r,n/r)}(t,e,s);let r=ht(t,a.first,i,n,s),o=1,m=0,h=0;do{if(o++,a.first*=.5,a.first<50*e.getTolerance(0))return r;a.second*=2,h=ht(t,a.first,i,n,s),m=Math.abs(h-r),r=h}while(Math.abs(r)>1&&m>1e-8*Math.abs(r)&&(a.second<65e3&&o<8||o<4));return h}function ht(t,e,i,n,s){const a=(new j.O).execute(t,e,0,0,s);let r;r=n?(new Q.v).execute(a,n,s):a;const o=1===i.getUnit().getUnitToBaseFactor()?Math.PI/180:1,m=new Z.j;r.queryEnvelope(m);const h=new Z.j,_=new Z.j,u=new Z.j;h.setCoords({xmin:m.xmin,ymin:75*o,xmax:m.xmax,ymax:90*o}),_.setCoords({xmin:m.xmin,ymin:-60*o,xmax:m.xmax,ymax:75*o}),u.setCoords({xmin:m.xmin,ymin:-90*o,xmax:m.xmax,ymax:-60*o}),h.inflateCoords(.01*h.width(),0),_.inflateCoords(.01*_.width(),0),u.inflateCoords(.01*u.width(),0);let c=0;return c+=_t(r,h,i,s),c+=_t(r,_,i,s),c+=_t(r,u,i,s),c}function _t(t,e,i,n){const s=(new tt.O).execute(t,e,i,n);if(null!==s&&!s.isEmpty()){const t=new Z.j;s.queryEnvelope(t);const{first:e,second:a}=function(t,e,i){const n=function(t,e,i){const n=t.getUnit().getUnitToBaseFactor(),s=e.getCenter();s.scale(180*n/Math.PI);const a=new J.P;a.x=0,a.y=0;let r=0;if(0===r){s.y>45?(a.y=J.l,r=0):s.y<-45?(a.y=-J.l,r=1):s.x>=45&&s.x<135?(a.x=J.l,r=2):s.x>=135||s.x<-135?(a.x=J.l,r=3):s.x<-45&&s.x>=-135?(a.x=-J.l,r=4):(a.x=0,r=5);const t=n*Math.sqrt((0,J.s)(e.xmin-e.xmax)+(0,J.s)(e.ymin-e.ymax)),i=a.clone(),o=e.getCenter();if(o.scale(n),r<2&&(i.x=o.x),J.P.distance(i,o)+.5*t>J.l)return null}const o=ut[r];if(null!==o&&o.getGCS().equalHorizontal(t))return o;const m=t.getText(),h=a.x,_=a.y,u=0,c=0;let l=0,p=-1;6!==r?p=Q.a4.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:((0,U.g)(i),l=0,p=Q.a4.PE_PRJ_CYLINDRICAL_EQAREA);const g=(0,Q.aw)("EqualAreaPCS");let y;p===Q.a4.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?y=`PROJCS["${g}",${m},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${c}],PARAMETER["Central_Meridian",${h}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:p===Q.a4.PE_PRJ_CYLINDRICAL_EQAREA?y=`PROJCS["${g}",${m},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${c}],PARAMETER["Central_Meridian",${h}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:(0,U.c)("getEqualAreaPcsFixed");const d=(0,Q.b)(y);return ut[r]&&ut[r].destroy(),ut[r]=d,d}(t,e,i);if(null!==n)return(0,J.n)(n,!1);const s=t.getText(),a=t.getUnit().getUnitToBaseFactor(),r=(e.xmin+e.width()/2)*a,o=(e.ymin+e.height()/2)*a,m=0,h=0;let _=0,u=0,c=-1;e.ymin*a>=75*Math.PI/180||e.ymax*a<=-60*Math.PI/180?c=Q.a4.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:e.ymin>0||e.ymax<0?(_=(e.ymin+1/3*e.height())*a,u=(e.ymin+2/3*e.height())*a,c=Q.a4.PE_PRJ_ALBERS):(_=(e.ymin+2/3*e.height())*a,c=Q.a4.PE_PRJ_CYLINDRICAL_EQAREA);const l=(0,Q.aw)("EqualAreaPCS");let p;return c===Q.a4.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?p=`PROJCS["${l}",${s},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${m}],PARAMETER["False_Northing",${h}],PARAMETER["Central_Meridian",${r}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:c===Q.a4.PE_PRJ_ALBERS?p=`PROJCS["${l}",${s},PROJECTION["Albers"],PARAMETER["False_Easting",${m}],PARAMETER["False_Northing",${h}],PARAMETER["Central_Meridian",${r}],PARAMETER["Standard_Parallel_1",${_}],PARAMETER["Standard_Parallel_2",${u}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:c===Q.a4.PE_PRJ_CYLINDRICAL_EQAREA?p=`PROJCS["${l}",${s},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${m}],PARAMETER["False_Northing",${h}],PARAMETER["Central_Meridian",${r}],PARAMETER["Standard_Parallel_1",${_}],PARAMETER["Latitude_of_Origin",${o}],UNIT["Meter",1.0]]`:(0,U.c)("getEqualAreaPCSInstance"),(0,J.n)((0,Q.b)(p),!0)}(i,t,!1),r=(0,Q.p)(i,e,null),o=(new Q.v).execute(s,r,n).calculateArea2D();return a&&e.destroy(),o}return 0}const ut=[null,null,null,null,null,null,null];class ct{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}execute(t,e,i){if(0===e.getCoordinateSystemType()&&(0,U.t)(""),t.isEmpty()||t.getDimension()<2)return 0;if((0,U.d)(t),t.getGeometryType()===U.G.enumEnvelope){const n=new $.a;return n.addEnvelope(t,!1),this.execute(n,e,i)}let n=t;t.getDescription().getAttributeCount()>1&&(n=t.clone(),n.dropAllAttributes());const s=(new j.O).execute(n,0,e.getTolerance(0),0,i);let a=null;const r=e.getGCS();r!==e&&(a=(0,Q.p)(e,r));let o=(new Q.g).execute(s,e,!1,i);return o.isEmpty()?0:(o===t&&(o=t.clone()),e.isPannable()?function(t,e,i){const n=new Z.j;t.queryEnvelope(n);const s=(0,K.a)(e,n,!0).total(),a=e.getPannableExtent();a.xmin=n.xmin-10*s,a.xmax=n.xmax+10*s;const r=(new tt.O).execute(t,a,e,i).getImpl().querySegmentIterator();r.stripAttributes();const o=(0,Q.G)();e.querySpheroidData(o);const m=o.e2,h=0===m?2:1,_=new J.P(0,0),u=new J.P(0,0),c=new J.K(0),l=new ot(_,u,e,m,100);for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();_.assign(t.getStartXY()),u.assign(t.getEndXY()),l.setSegmentEndPoints(_,u);const e=(0,$.x)(6,0,1,1e-12,1e-15,l.makeFunctor());c.pe((u.x-_.x)*e)}const p=o.majorSemiAxis;return h*p*p*(1-m)*Math.PI*c.getResult()/e.getPannableExtent().width()}(o,e,i):mt(o,e,r,a,i))}}function lt(){return{m_p_PCS:new J.P,m_factor:Number.NaN,setValues:pt,assign:gt}}function pt(t,e){this.m_factor=t,this.m_p_PCS.assign(e)}function gt(t){this.m_factor=t.m_factor,this.m_p_PCS.assign(t.m_p_PCS)}class yt{constructor(t,e,i,n){this.m_ptStart=new K.h,this.m_ptEnd=new K.h,this.m_ptStart.assign(e),this.m_ptEnd.assign(i),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(t),this.m_e2=t,this.m_c1MinusE2=1-t;const s=Math.sin(n);let a;a=0===this.m_e2?2*s:s*((0,J.y)(this.m_e*s)+1/(1-this.m_e2*s*s)),this.m_baseA=a}setSegmentEndPoints(t,e){this.m_ptStart.assign(t),this.m_ptEnd.assign(e),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return t=>{const e=1-t,i=e*this.m_ptStart.x+t*this.m_ptEnd.x,n=e*this.m_ptStart.y+t*this.m_ptEnd.y,s=e*this.m_ptStart.z+t*this.m_ptEnd.z,a=i*i+n*n,r=s/Math.sqrt(s*s+this.m_c1MinusE2*this.m_c1MinusE2*a);let o;return o=0===this.m_e2?2*r:r*((0,J.y)(this.m_e*r)+1/(1-this.m_e2*r*r)),(this.m_deltaY*i-this.m_deltaX*n)/a*(o-this.m_baseA)}}}function dt(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:Pt,changeSign:xt,assign:ft,clone:St}}function Pt(t,e,i,n){const s=.5*t;this.sin_phi=Math.sin(t);const a=e*this.sin_phi,r=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(s+i),this.sin_half_phi_pz=Math.sin(s+n),this.sin_half_asin_e_sin_phi_pf=Math.sin(r+i),this.sin_half_asin_e_sin_phi_pz=Math.sin(r+n),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function xt(){this.sin_phi=-this.sin_phi;let t=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=t,t=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=t,t=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=t,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function ft(t){this.sin_phi=t.sin_phi,this.one_p_sin_phi=t.one_p_sin_phi,this.one_m_sin_phi=t.one_m_sin_phi,this.one_m_e_2_sin_2_phi=t.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=t.sin_half_phi_pf,this.sin_half_phi_pz=t.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=t.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=t.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=t.atanh_sin_phi,this.atanh_esin_phi=t.atanh_esin_phi,this.make_negative=t.make_negative}function St(){return{...this}}class Et{constructor(t,e,i){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new nt.T,this.m_scaleToDegrees=new nt.T,this.m_progressTracker=i,(0,U.g)(4!==e),this.m_curveType=e,this.m_inputSR=t,t&&0!==t.getCoordinateSystemType()||(0,U.t)(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(t){let e,i=t.clone();if(i.dropAllAttributes(),t.hasNonLinearSegments()&&(i=(new j.O).execute(i,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const t=new Z.j;i.queryEnvelope(t);const e=this.m_inputSR.getPannableExtent();if(!e.containsEnvelope(t)){const n=e.getCenterX()-t.getCenterX(),s=new nt.T;s.setShiftCoords(n,0),i.applyTransformation(s),t.move(n,0);const a=new J.E;e.queryIntervalX(a);const r=new J.E;t.queryIntervalX(r),i=a.contains(r)?(0,Q.w)(i,this.m_inputSR):(new Q.v).foldInto360RangeGeodetic(i,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(i=(new Q.g).execute(i,this.m_inputSR,!1,this.m_progressTracker),e=i.createInstance(),(0,Q.$)(this.m_transformPCS2GCS,i,e,this.m_progressTracker)||(e=(new Q.v).execute(i,this.m_transformPCS2GCS,this.m_progressTracker))):e=(new Q.g).execute(i,this.m_inputGCS,!1,this.m_progressTracker),e.isEmpty())return 0;if(1===this.m_curveType){const t=(0,Q.G)();return this.m_inputGCS.querySpheroidData(t),this.m_a=t.majorSemiAxis,this.m_eSquared=t.e2,this.loxodromeArea(e)}const n=e.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),n.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const s=(0,Q.G)();if(this.m_inputGCS.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_b=s.minorSemiAxis,this.m_eSquared=s.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(e);{const t={stack:[],error:void 0,hasError:!1};try{const i=Q.ax.unit(9101),n=this.m_inputGCS.getPECoordSys(),s=(0,it.b)(t,n.cloneAlterUnits(i),!1);let a,r,o=this.executeClippedPolygonGeodeticArea(e,s,0),m=0;do{m++,a=this.executeClippedPolygonGeodeticArea(e,s,m),r=Math.abs(a-o),o=a}while(Math.abs(a)>1&&r>1e-8*Math.abs(a)&&m<7);return a}catch(e){t.error=e,t.hasError=!0}finally{(0,it.c)(t)}}}executeClippedPolygonGeodeticArea(t,e,i){const n={stack:[],error:void 0,hasError:!1};try{const s=new Z.j;t.queryEnvelope(s);const a=(0,it.b)(n,this.getEqualAreaPCSInstance(e,s),!1),r=t.clone();(0,Q.ay)(a,r);const o=50,m=r.getImpl().getAttributeStreamRef(0),h=t.getImpl().getAttributeStreamRef(0),_=(0,it.b)(n,new Q.E,!1),u=(0,it.b)(n,new Q.E,!1),c=40,l=[0,0],p=(0,J.p)(lt,c),g=(0,J.d)(c,-1),y=lt(),d=lt();let P,x;const f=a;let S=r.calculateArea2D();const E=new J.K(0),M=.5*Math.PI,v=1e-10*Math.abs(S)+1e-6,D=t.getPathCount();let T,G,b,w;const N=new J.P,A=new J.P,C=new J.P,I=new J.P,R=new J.P,q=new J.P;let B,Y;for(G=t.getPathStart(0),T=0;T<D;T++,G=b)for(b=t.getPathEnd(T),m.queryPoint2D(b-1<<1,C),h.queryPoint2D(b-1<<1,N),Math.abs(N.y)>M&&(N.y=(0,J.f)(M,N.y)),w=G;w<b;w++,C.assign(I),N.assign(A)){if(m.queryPoint2D(w<<1,I),h.queryPoint2D(w<<1,A),Math.abs(A.y)>M&&(A.y=(0,J.f)(M,A.y)),B=J.P.distance(C,I),B<o||0===N.y&&0===A.y)continue;Q.F.geodeticDistance(this.m_a,this.m_eSquared,N.x,N.y,A.x,A.y,_,u,null,this.m_curveType);const t=_.val,e=u.val;for(y.setValues(0,C),d.setValues(1,I),x=i,p[0].assign(d),g[0]=i,P=0;P>=0;){Y=.5*(y.m_factor+d.m_factor),Q.F.geodeticCoordinate(this.m_a,this.m_eSquared,N.x,N.y,t*Y,e,_,u,this.m_curveType),R.x=_.val,R.y=u.val,l[0]=R.x,l[1]=R.y,Q.Z.geogToProj(f,1,l),q.x=l[0],q.y=l[1];const i=.5*-q.offset(y.m_p_PCS,d.m_p_PCS)*J.P.distance(y.m_p_PCS,d.m_p_PCS);if(E.pe(i),Math.abs(i)>v||Math.abs(i)>0&&x>0)d.setValues(Y,q),P++,p[P].assign(d),Math.abs(i)<=v?(x--,g[P-1]=x,g[P]=x):(x=g[P-1],g[P]=x);else{if(P<=0)break;y.assign(d),P--,d.assign(p[P]),x=g[P]}}}return S+=E.getResult(),Math.abs(S)}catch(t){n.error=t,n.hasError=!0}finally{(0,it.c)(n)}}executeClippedPolygonGreatEllipticArea(t){const e=[],i=[],n=new J.P,s=new J.P,a=(0,Q.Q)(1,this.m_eSquared,new J.P(0,.5*Math.PI)),r=new J.K(0),o=new J.K(0),m=new J.K(0),h=new K.h,_=new K.h,u=new Z.j;t.queryLooseEnvelope(u);let c=0;u.containsCoords(u.xmin,0)||(c=Math.abs(u.ymin)<Math.abs(u.ymax)?u.ymin:u.ymax);const l=new yt(this.m_eSquared,h,_,c),p=this.m_a*this.m_a,g=t.getImpl().querySegmentIterator();for(g.stripAttributes();g.nextPath();)for(;g.hasNextSegment();){const t=g.nextSegment();n.assign(t.getStartXY()),s.assign(t.getEndXY()),s.x-n.x>Math.PI?n.x+=2*Math.PI:s.x-n.x<-Math.PI&&(s.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(t,e,i);for(let t of e)h.assign((0,Q.Q)(this.m_a,this.m_eSquared,t.getStartXY())),_.assign((0,Q.Q)(this.m_a,this.m_eSquared,t.getEndXY())),l.setSegmentEndPoints(h,_),this.adaptiveIntegrationWithRomberg(l,r);for(let t of i){let e=t.getStartXY(),i=t.getEndXY(),n=c;e.y<0&&(i=(0,J.b)(e,e=i),e.y=-e.y,i.y=-i.y,n=-n);const s=(0,Q.Q)(1,this.m_eSquared,e),r=(0,Q.Q)(1,this.m_eSquared,i),h=Math.min(e.y,i.y),_=(0,Q.az)(this.m_eSquared,e.x,i.x,n,h);o.pe(_);const u=Math.abs((0,Q.az)(this.m_eSquared,e.x,i.x,h,J.l)),l=new K.h;l.setSub(s,a);const g=new K.h;g.setSub(r,a);const y=new K.h;y.setCrossProductVector(l,g);let d=p*(u-.5*y.length());d=(0,J.f)(d,i.x-e.x),m.pe(d)}e.length=0,i.length=0}return m.getResult()+p*(.5*(1-this.m_eSquared)*r.getResult()+o.getResult())}getEqualAreaPCSInstance(t,e){const i=e.getCenterX();let n,s;const a=e.height();let r,o;(r=e.ymin>45*Math.PI/180||e.ymax<45*-Math.PI/180)?n=(0,J.f)(.5*Math.PI,e.getCenterY()):(n=e.getCenterY(),s=e.ymin+a*(2/3));const m=(0,Q.aw)("EqualAreaPCS"),h=t.toString();return o=r?Q.ax.fromString(Q.a4.PE_TYPE_PROJCS,`PROJCS["${m}", ${h}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}], PARAMETER["Latitude_of_Origin", ${n}], UNIT["Meter",1.0]]`):Q.ax.fromString(Q.a4.PE_TYPE_PROJCS,`PROJCS["${m}", ${h}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}],PARAMETER["Standard_Parallel_1", ${s}],PARAMETER["Latitude_of_Origin", ${n}],UNIT["Meter",1.0]]`),o}splitSegmentCrossingItegralThreshold(t,e,i){const n=100,s=20,a=400,r=(0,Q.Q)(this.m_a,this.m_eSquared,new J.P(0,J.l)),o=(0,Q.Q)(this.m_a,this.m_eSquared,new J.P(0,-J.l)),m=this.splitSegmentPassingThroughPole(t);for(let t of m){const m=t.getStartXY(),h=t.getEndXY(),_=(0,Q.Q)(this.m_a,this.m_eSquared,m),u=(0,Q.Q)(this.m_a,this.m_eSquared,h),c=new J.P,l=new K.h;let p=K.h.sqrDistance(r,_),g=K.h.sqrDistance(_,u);if(p<=n){if(!(g>a)){i.push(new $.L({start:m,end:h}));continue}l.assign(u.sub(_)),l.normalizeThis(),l.assign(_.add(l.mul(s))),c.assign((0,Q.Y)(this.m_a,this.m_eSquared,l)),i.push(new $.L({start:m,end:c})),m.assign(c)}if(_.assign((0,Q.Q)(this.m_a,this.m_eSquared,m)),p=K.h.sqrDistance(r,u),g=K.h.sqrDistance(_,u),p<=n){if(!(g>a)){i.push(new $.L({start:m,end:h}));continue}l.assign(u.sub(_)),l.normalizeThis(),l.assign(u.sub(l.mul(s))),c.assign((0,Q.Y)(this.m_a,this.m_eSquared,l)),i.push(new $.L({start:c,end:h})),h.assign(c)}if(_.assign((0,Q.Q)(this.m_a,this.m_eSquared,m)),u.assign((0,Q.Q)(this.m_a,this.m_eSquared,h)),p=K.h.sqrDistance(o,_),g=K.h.sqrDistance(_,u),p<=n){if(!(g>a)){i.push(new $.L({start:m,end:h}));continue}l.assign(u.sub(_)),l.normalizeThis(),l.assign(_.add(l.mul(s))),c.assign((0,Q.Y)(this.m_a,this.m_eSquared,l)),i.push(new $.L({start:m,end:c})),m.assign(c)}if(_.assign((0,Q.Q)(this.m_a,this.m_eSquared,m)),u.assign((0,Q.Q)(this.m_a,this.m_eSquared,h)),p=K.h.sqrDistance(o,u),g=K.h.sqrDistance(_,u),p<=n){if(!(g>a)){i.push(new $.L({start:m,end:h}));continue}l.assign(u.sub(_)),l.normalizeThis(),l.assign(u.sub(l.mul(s))),c.assign((0,Q.Y)(this.m_a,this.m_eSquared,l)),i.push(new $.L({start:c,end:h})),h.assign(c)}e.push(new $.L({start:m,end:h}))}}splitSegmentPassingThroughPole(t){const e={stack:[],error:void 0,hasError:!1};try{const i=[],n=new K.h,s=new K.h,a=new K.h,r=new J.P,o=20,m=3.124139361,h=10,_=t.getStartXY(),u=t.getEndXY(),c=(0,it.b)(e,new Q.E,!1);if(Q.F.geodeticDistance(this.m_a,this.m_eSquared,_.x,_.y,u.x,u.y,c,null,null,2),Math.abs(u.x-_.x)>m&&c.val>o){const t=new at(new J.P(0,90),_.divide(this.m_rpu),u.divide(this.m_rpu),this.m_inputGCS,2,2);let e=(0,Q.U)(t.makeFunctor(),0,1,1e-10);if(e.second<=h&&e.first>0&&e.first<1)return n.assign((0,Q.Q)(this.m_a,this.m_eSquared,_)),s.assign((0,Q.Q)(this.m_a,this.m_eSquared,u)),(0,J.x)(n,s,e.first,a),r.assign((0,Q.Y)(this.m_a,this.m_eSquared,a)),i.push(new $.L({start:_,end:r})),i.push(new $.L({start:r,end:u})),i;if(t.setPointDistFrom(new J.P(0,-90)),e=(0,Q.U)(t.makeFunctor(),0,1,1e-10),e.second<=h&&e.first>0&&e.first<1)return n.assign((0,Q.Q)(this.m_a,this.m_eSquared,_)),s.assign((0,Q.Q)(this.m_a,this.m_eSquared,u)),(0,J.x)(n,s,e.first,a),r.assign((0,Q.Y)(this.m_a,this.m_eSquared,a)),i.push(new $.L({start:_,end:r})),i.push(new $.L({start:r,end:u})),i}return i.push(new $.L({start:_,end:u})),i}catch(t){e.error=t,e.hasError=!0}finally{(0,it.c)(e)}}adaptiveIntegrationWithRomberg(t,e){const i=t.makeFunctor();let n=0,s=1,a=i(n),r=i(s);const o=1e-17,m=1e-14;let h=(n+s)/2,_=i(h),u=Math.abs(_-a),c=Math.abs(r-_),l=0;for(;l++<32&&(u/c<.1||c/u<.1);)u<c?(e.pe((0,$.x)(5,n,h,m,o,i)),n=h,a=_):(e.pe((0,$.x)(5,h,s,m,o,i)),s=h,r=_),h=(n+s)/2,_=Math.abs(i(h)),u=Math.abs(_-a),c=Math.abs(r-_);e.pe((0,$.x)(5,n,s,m,o,i))}loxodromeAreaHemi(t,e,i,n,s){const a=i.clone(),r=s.clone();let o,m,h,_,u,c,l,p,g,y,d,P,x,f,S,E;return a.make_negative&&a.changeSign(),r.make_negative&&r.changeSign(),d=n-e,1===Math.abs(a.sin_phi)||1===Math.abs(r.sin_phi)?t.half_qp*d:a.sin_phi===r.sin_phi?(y=.5*t.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,J.y)(t.e*a.sin_phi))*d,y):(S=Math.log(r.sin_half_phi_pf*a.sin_half_phi_pz/(r.sin_half_phi_pz*a.sin_half_phi_pf)),E=Math.log(r.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(r.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(u=0,o=.5*(S+r.sin_phi/r.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),m=0):(u=-2*t.atanh_e_over_e*(Math.log(r.one_p_sin_phi/a.one_p_sin_phi)-t.e*E),o=(S-t.e*E)/t.one_m_e_2,m=(Math.log(r.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+u/t.atanh_e_over_e)/t.one_m_e_2),h=-E*(a.atanh_esin_phi+r.atanh_esin_phi),_=1/a.one_m_e_2_sin_2_phi-1/r.one_m_e_2_sin_2_phi,c=(0,J.z)(r.one_m_sin_phi/t.one_p_e,t.e)-(0,J.z)(a.one_m_sin_phi/t.one_p_e,t.e),l=(0,J.z)(r.one_p_sin_phi/t.one_p_e,t.e)-(0,J.z)(a.one_p_sin_phi/t.one_p_e,t.e),p=(0,J.z)(a.one_m_sin_phi/-t.one_m_e,t.e)-(0,J.z)(r.one_m_sin_phi/-t.one_m_e,t.e),g=(0,J.z)(a.one_p_sin_phi/-t.one_m_e,t.e)-(0,J.z)(r.one_p_sin_phi/-t.one_m_e,t.e),y=.25/o*(m+h+_+u+.5*(c+l+p+g)),y+=t.half_qp,P=.5*t.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,J.y)(t.e*a.sin_phi)),x=.5*t.one_m_e_2*r.sin_phi*(1/r.one_m_e_2_sin_2_phi+(0,J.y)(t.e*r.sin_phi)),x<P&&(f=P,P=x,x=f),y<P&&(y=P),y>x&&(y=x),y*=d,y)}loxodromeArea(t){const e=Math.PI/180;let i=0;const n={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},s=dt(),a=dt();n.e=Math.sqrt(this.m_eSquared),n.one_p_e=1+n.e,n.one_m_e=1-n.e,n.one_m_e_2=1-this.m_eSquared,n.atanh_e_over_e=(0,J.y)(n.e),this.m_eSquared>=1?n.half_qp=1:n.half_qp=.5*(1+n.atanh_e_over_e*n.one_m_e_2),n.f=.25*Math.PI,n.z=.75*Math.PI,a.initialize(0,n.e,n.f,n.z);const r=t.getPathCount(),o=new J.P,m=new J.P,h=t.getImpl().getAttributeStreamRef(0);for(let _=0;_<r;_++){const r=t.getPathStart(_),u=t.getPathEnd(_);if(!(u-r<=1)){h.queryPoint2D(2*(u-1),o);for(let t=r;t<u;t++){h.queryPoint2D(2*t,m);const _=o.y*e,u=m.y*e;if(t===r?(s.initialize(_,n.e,n.f,n.z),s.make_negative=!1):s.assign(a),a.initialize(u,n.e,n.f,n.z),a.make_negative=!1,o.y*m.y<0){if(o.y>=90&&m.y<=-90||m.y>=90&&o.y<=-90)return Number.NaN;const t=dt();t.initialize(0,n.e,n.f,n.z),t.make_negative=!1;const r=s.atanh_sin_phi-n.e*s.atanh_esin_phi,h=a.atanh_sin_phi-n.e*a.atanh_esin_phi,u=(h*o.x-r*m.x)/(h-r);_<0?(s.make_negative=!0,i-=this.loxodromeAreaHemi(n,o.x*e,s,u*e,t),s.make_negative=!1,i+=this.loxodromeAreaHemi(n,u*e,t,m.x*e,a)):(i+=this.loxodromeAreaHemi(n,o.x*e,s,u*e,t),a.make_negative=!0,i-=this.loxodromeAreaHemi(n,u*e,t,m.x*e,a),a.make_negative=!1)}else o.y>=0?i+=this.loxodromeAreaHemi(n,o.x*e,s,m.x*e,a):(s.make_negative=!0,a.make_negative=!0,i-=this.loxodromeAreaHemi(n,o.x*e,s,m.x*e,a),s.make_negative=!1,a.make_negative=!1);o.assign(m)}}}return this.m_a*i*this.m_a}calculate(t){if(t.isEmpty()||t.getDimension()<2)return 0;if(t.getGeometryType()===U.G.enumEnvelope){const e=new $.a;return e.addEnvelope(t,!1),this.calculate(e)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=(0,Q.p)(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(t)}}class Mt{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}execute(t,e,i,n){return(0,U.d)(t),4===i?(new ct).execute(t,e,n):new Et(e,i,n).calculate(t)}}},47239:(t,e,i)=>{i.r(e),i.d(e,{OperatorGeodeticDensifyByLength:()=>r,OperatorGeodeticDensifyCursor:()=>o});var n=i(48687),s=i(73479),a=i(26166);class r{getOperatorType(){return 10310}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,i,n,s){return new o(t,i,n,e,-1,-1,s)}execute(t,e,i,a,r){const o=new n.S([t]),m=this.executeMany(o,e,i,a,r).next();return m||(0,s.c)("null output"),m}}class o extends n.G{constructor(t,e,i,n,a,r,o){super(),this.m_progressTracker=o,r>0&&(0,s.b)(""),4!==i&&a>0&&(0,s.b)(""),e||(0,s.t)(""),0===e.getCoordinateSystemType()&&(0,s.t)(""),n>0||a>0||(0,s.t)(""),this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_curveType=i,this.m_maxLengthMeters=n,this.m_maxDeviationMeters=a,this.m_maxAngle=r}next(){{let t;for(;t=this.m_inputGeoms.next();)return(0,s.d)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.geodeticDensify(t);return null}}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodeticDensify(t){return(0,a.u)(t,this.m_spatialReference,this.m_curveType,this.m_maxLengthMeters,this.m_maxDeviationMeters,this.m_progressTracker)}}},79124:(t,e,i)=>{i.d(e,{O:()=>g});var n=i(73479),s=i(26166),a=i(21990),r=i(29778),o=i(42379),m=i(93758),h=i(66886),_=i(66162);function u(){return{m_pGcs:new r.P,m_xyz:new o.h,m_factor:Number.NaN,m_geoLength:Number.NaN,setValues:c,setLength:l,assign:p}}function c(t,e,i,n){this.m_factor=t,this.m_pGcs.assign(e),this.m_xyz.assign(n),this.m_geoLength=i}function l(t){this.m_geoLength=t}function p(t){this.m_pGcs.assign(t.m_pGcs),this.m_xyz.assign(t.m_xyz),this.m_factor=t.m_factor,this.m_geoLength=t.m_geoLength}class g{getOperatorType(){return 10315}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}_ExecuteShapePreservingLength(t,e,i,n,a){if(t.hasNonLinearSegments()&&(t=(new h.O).execute(t,0,e.getTolerance(0),0,a)),e.isPannable()){let n=90,r=-90;if(1===i.getUnit().getUnitToBaseFactor()&&(n*=Math.PI/180,r*=Math.PI/180),2===e.getCoordinateSystemType()){let t=null;const i=[0,0,0,0];t=e.getPECoordSys(),i[0]=0,i[1]=n,i[2]=0,i[3]=r,s.Z.geogToProj(t,2,i),n=i[1],r=i[3]}const o=new m.j;t.queryEnvelope(o),o.ymin=r,o.ymax=n,t=(new _.O).execute(t,o,e,a)}else{const i=e.getPCSHorizon();if((t=(new s.f).execute(t,i,e,a))===i){const e=t.clone();t=e}}return t.isEmpty()?0:this._ExecuteIterativeApproach(t,e,i,n,1,a)}_ExecuteIterativeApproach(t,e,i,a,m,h){const _=(0,s.G)();i.querySpheroidData(_);const c=_.majorSemiAxis,l=_.e2,p=i.getUnit().getUnitToBaseFactor(),g=(0,r.p)(u,40),P=(0,r.d)(40,Number.NaN),x=u(),f=u();let S;const E=[0,0,0,0],M=e.getPECoordSys(),v=new r.P,D=new r.P,T=new r.P,G=new r.P,b=new r.P;let w=0;const N=t.querySegmentIterator();for(;N.nextPath();)for(;N.hasNextSegment();){const t=N.nextSegment();v.assign(t.getStartXY()),D.assign(t.getEndXY()),2===e.getCoordinateSystemType()?(E[0]=v.x,E[1]=v.y,E[2]=D.x,E[3]=D.y,s.Z.projToGeog(M,2,E),T.x=E[0]*p,T.y=E[1]*p,G.x=E[2]*p,G.y=E[3]*p):(T.setCoordsPoint2D(v),G.setCoordsPoint2D(D),T.scale(p),G.scale(p));const i=new o.h,a=new o.h;y(c,l,T,i),y(c,l,G,a);let r=d(c,i,a);x.setValues(0,T,Number.NaN,i),f.setValues(1,G,r,a),S=m,g[0].assign(f),P[0]=m;let h=0;for(;;){h>128&&(0,n.c)("iterations exceeded");const i=.5*(x.m_factor+f.m_factor),a=t.getCoord2D(i);2===e.getCoordinateSystemType()?(E[0]=a.x,E[1]=a.y,s.Z.projToGeog(M,1,E),b.x=E[0]*p,b.y=E[1]*p):(b.setCoordsPoint2D(a),b.scale(p)),T.setCoordsPoint2D(x.m_pGcs),G.setCoordsPoint2D(f.m_pGcs);const _=new o.h;y(c,l,b,_);const u=d(c,x.m_xyz,_),v=d(c,f.m_xyz,_);r=f.m_geoLength,Number.isNaN(r)&&(r=d(c,x.m_xyz,f.m_xyz));const D=u+v,N=S===m&&D>=20&&Math.abs(D-r)>1e-8*(r+D);if(h+2<40&&(N||Math.abs(D-r)>0&&S>0))f.setLength(v),g[h].assign(f),f.setValues(i,b,u,_),g[++h].assign(f),N?(S=m,P[h]=m):(S--,P[h-1]=S,P[h]=S);else{if(w+=D,0===h)break;x.assign(f),f.assign(g[--h]),S=P[h]}}}return w}execute(t,e,i){if(e&&0!==e.getCoordinateSystemType()||(0,n.t)(""),t.isEmpty()||t.getDimension()<1)return 0;let r=null;const o=e.getGCS();o!==e&&(r=(0,s.p)(e,o,null));const m=t.getGeometryType();if(m===n.G.enumEnvelope){const n=new a.a;return n.addEnvelope(t,!1),this._ExecuteShapePreservingLength(n,e,o,r,i)}if((0,n.f)(m)){const n=new a.P;return n.addSegment(t,!0),this._ExecuteShapePreservingLength(n,e,o,r,i)}return this._ExecuteShapePreservingLength(t,e,o,r,i)}}function y(t,e,i,n){n.assign((0,s.Q)(t,e,i))}function d(t,e,i){const n=t,s=new o.h;s.setSub(e,i);const a=s.length();return 2*n*Math.asin(a/(2*n))}},48687:(t,e,i)=>{i.d(e,{G:()=>n,S:()=>s});class n{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends n{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);