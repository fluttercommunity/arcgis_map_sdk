"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[35399],{43057:(e,t,i)=>{i.d(t,{Z:()=>y});var a=i(43405);const n={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const r=new(i(78311).B)((function(e){let t=n;return e.split("/").forEach((e=>{t&&(t=t[e])})),t}));function l(e){return r.resolveIncludes(e)}var o=i(73353);const s=e=>(0,o.K)({PATTERN:e.pattern}),c={shaders:e=>({vertexShader:s(e)+l("background/background.vert"),fragmentShader:s(e)+l("background/background.frag")})},u={shaders:e=>({vertexShader:l("circle/circle.vert"),fragmentShader:l("circle/circle.frag")})},d=e=>(0,o.K)({PATTERN:e.pattern}),p={shaders:e=>({vertexShader:d(e)+l("fill/fill.vert"),fragmentShader:d(e)+l("fill/fill.frag")})},f={shaders:e=>({vertexShader:l("outline/outline.vert"),fragmentShader:l("outline/outline.frag")})},m=e=>(0,o.K)({SDF:e.sdf}),_={shaders:e=>({vertexShader:m(e)+l("icon/icon.vert"),fragmentShader:m(e)+l("icon/icon.frag")})},h=e=>(0,o.K)({PATTERN:e.pattern,SDF:e.sdf}),v={shaders:e=>({vertexShader:h(e)+l("line/line.vert"),fragmentShader:h(e)+l("line/line.frag")})},g={shaders:e=>({vertexShader:l("text/text.vert"),fragmentShader:l("text/text.frag")})};class y{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,t,i){const a=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(a))return this._programByKey.get(a);const n=this._getProgramTemplate(t.type),{shaders:r}=n,{vertexShader:l,fragmentShader:o}=r(i),s=t.getShaderHeader(),c=t.getShaderMain(),u=l.replace("#pragma header",s).replace("#pragma main",c),d=e.programCache.acquire(u,o,t.getAttributeLocations());return this._programByKey.set(a,d),d}_getMaterialOptionsValue(e,t){switch(e){case a._K.BACKGROUND:case a._K.FILL:return(t.pattern?1:0)<<1;case a._K.OUTLINE:return 0;case a._K.LINE:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1}case a._K.ICON:return(t.sdf?1:0)<<1;case a._K.CIRCLE:case a._K.TEXT:default:return 0}}_getProgramTemplate(e){switch(e){case a._K.BACKGROUND:return c;case a._K.CIRCLE:return u;case a._K.FILL:return p;case a._K.ICON:return _;case a._K.LINE:return v;case a._K.OUTLINE:return f;case a._K.TEXT:return g;default:return null}}}},71200:(e,t,i)=>{i.d(t,{k3:()=>l,s5:()=>r});Math.PI;const a=1/Math.LN2;function n(e,t){return(e%=t)>=0?e:e+t}function r(e){return n(.7111111111111111*e,256)}function l(e){return Math.log(e)*a}},29316:(e,t,i)=>{i.d(t,{Z:()=>a});class a{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,t){}draw(e,t,i){}drawMany(e,t,i){for(const a of t)a.visible&&this.draw(e,a,i)}}},10929:(e,t,i)=>{i.d(t,{J:()=>d});var a=i(19431),n=i(38642),r=i(55939),l=i(14266),o=i(29316),s=i(78951),c=i(91907),u=i(29620);class d extends o.Z{constructor(){super(...arguments),this._color=(0,r.al)(1,0,0,1),this._patternMatrix=(0,n.Ue)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,t){const{context:i,painter:n,requestRender:r,allowDelayedRender:o}=e;this._loadWGLResources(e);const s=e.displayLevel,u=e.styleLayer,d=u.backgroundMaterial,p=n.vectorTilesMaterialManager,f=u.getPaintValue("background-color",s),m=u.getPaintValue("background-opacity",s),_=u.getPaintValue("background-pattern",s),h=void 0!==_,v=1|window.devicePixelRatio,g=e.spriteMosaic;let y,x;const w=v>l.Vo?2:1,b=this._programOptions;b.pattern=h;const M=p.getMaterialProgram(i,d,b);if(!o||null==r||M.compiled){if(i.bindVAO(this._vao),i.useProgram(M),h){const e=g.getMosaicItemPosition(_,!0);if(null!=e){const{tl:t,br:a,page:n}=e;y=a[0]-t[0],x=a[1]-t[1];const r=g.getPageSize(n);null!=r&&(g.bind(i,c.cw.LINEAR,n,l.dD),M.setUniform4f("u_tlbr",t[0],t[1],a[0],a[1]),M.setUniform2fv("u_mosaicSize",r),M.setUniform1i("u_texture",l.dD))}M.setUniform1f("u_opacity",m)}else{const e=f[3]*m;this._color[0]=e*f[0],this._color[1]=e*f[1],this._color[2]=e*f[2],this._color[3]=e,M.setUniform4fv("u_color",this._color)}M.setUniform1f("u_depth",u.z||0);for(const e of t){if(M.setUniform1f("u_coord_range",e.rangeX),M.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),h){const t=Math.max(2**(Math.round(s)-e.key.level),1),i=w*e.width*t,n=i/(0,a.fp)(y),r=i/(0,a.fp)(x);this._patternMatrix[0]=n,this._patternMatrix[4]=r,M.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}i.setStencilFunction(c.wb.EQUAL,0,255),i.drawArrays(c.MX.TRIANGLE_STRIP,0,4)}}else r()}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,a=i.backgroundMaterial,n=new Int8Array([0,0,1,0,0,1,1,1]),r=s.f.createVertex(t,c.l1.STATIC_DRAW,n),l=new u.U(t,a.getAttributeLocations(),a.getLayoutInfo(),new Map([["geometry",r]]));this._vao=l}}},92677:(e,t,i)=>{i.d(t,{j:()=>l});var a=i(93712),n=i(29316),r=i(91907);class l extends n.Z{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:n,requiredLevel:l,state:o,painter:s,spriteMosaic:c,styleLayerUID:u,requestRender:d,allowDelayedRender:p}=e;if(!t.some((e=>e.layerData.get(u)?.circleIndexCount??!1)))return;const f=e.styleLayer,m=f.circleMaterial,_=s.vectorTilesMaterialManager,h=f.getPaintValue("circle-translate",n),v=f.getPaintValue("circle-translate-anchor",n),g=this._programOptions,y=_.getMaterialProgram(i,m,g);if(p&&null!=d&&!y.compiled)return void d();i.useProgram(y),y.setUniformMatrix3fv("u_displayMat3",v===a.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),y.setUniform2fv("u_circleTranslation",h),y.setUniform1f("u_depth",f.z),y.setUniform1f("u_antialiasingWidth",1.2);let x=-1;for(const e of t){if(!e.layerData.has(u))continue;e.key.level!==x&&(x=e.key.level,m.setDataUniforms(y,n,f,x,c));const t=e.layerData.get(u);if(!t.circleIndexCount)continue;t.prepareForRendering(i);const a=t.vao;null!=a&&(i.bindVAO(a),y.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),l!==e.key.level?i.setStencilFunction(r.wb.EQUAL,e.stencilRef,255):i.setStencilFunction(r.wb.GREATER,255,255),i.drawElements(r.MX.TRIANGLES,t.circleIndexCount,r.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.circleIndexStart),e.triangleCount+=t.circleIndexCount/3)}}}},28035:(e,t,i)=>{i.d(t,{R:()=>s});var a=i(93712),n=i(14266),r=i(29316),l=i(91907);const o=1/65536;class s extends r.Z{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,renderPass:a,spriteMosaic:n,styleLayerUID:r}=e;let l=!1;for(const e of t)if(e.layerData.has(r)){const t=e.layerData.get(r);if(t.fillIndexCount>0||t.outlineIndexCount>0){l=!0;break}}if(!l)return;const o=e.styleLayer,s=o.getPaintProperty("fill-pattern"),c=void 0!==s,u=c&&s.isDataDriven;let d;if(c&&!u){const e=s.getValue(i);d=n.getMosaicItemPosition(e,!0)}const p=!c&&o.getPaintValue("fill-antialias",i);let f=!0,m=1;if(!c){const e=o.getPaintProperty("fill-color"),t=o.getPaintProperty("fill-opacity");if(!e?.isDataDriven&&!t?.isDataDriven){const e=o.getPaintValue("fill-color",i);m=o.getPaintValue("fill-opacity",i)*e[3],m>=1&&(f=!1)}}if(f&&"opaque"===a)return;const _=o.getPaintValue("fill-translate",i),h=o.getPaintValue("fill-translate-anchor",i);(f||"translucent"!==a)&&this._drawFill(e,r,o,t,_,h,c,d,u);const v=!o.hasDataDrivenOutlineColor&&o.outlineUsesFillColor&&m<1;p&&"opaque"!==a&&!v&&this._drawOutline(e,r,o,t,_,h)}_drawFill(e,t,i,r,s,c,u,d,p){if(u&&!p&&null==d)return;const{context:f,displayLevel:m,state:_,painter:h,pixelRatio:v,spriteMosaic:g,requestRender:y,allowDelayedRender:x}=e,w=i.fillMaterial,b=h.vectorTilesMaterialManager,M=v>n.Vo?2:1,S=this._fillProgramOptions;S.pattern=u;const C=b.getMaterialProgram(f,w,S);if(x&&null!=y&&!C.compiled)return void y();if(f.useProgram(C),null!=d){const{page:e}=d,t=g.getPageSize(e);null!=t&&(g.bind(f,l.cw.LINEAR,e,n.dD),C.setUniform2fv("u_mosaicSize",t),C.setUniform1i("u_texture",n.dD))}C.setUniformMatrix3fv("u_displayMat3",c===a.fD.VIEWPORT?_.displayMat3:_.displayViewMat3),C.setUniform2fv("u_fillTranslation",s),C.setUniform1f("u_depth",i.z+o);let T=-1;for(const e of r){if(!e.layerData.has(t))continue;e.key.level!==T&&(T=e.key.level,w.setDataUniforms(C,m,i,T,g));const a=e.layerData.get(t);if(!a.fillIndexCount)continue;a.prepareForRendering(f);const r=a.fillVAO;if(null!=r){if(f.bindVAO(r),C.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),f.setStencilFunction(l.wb.EQUAL,e.stencilRef,255),u){const t=Math.max(2**(Math.round(m)-e.key.level),1),i=e.rangeX/(M*e.width*t);C.setUniform1f("u_patternFactor",i)}if(p){const e=a.patternMap;if(!e)continue;for(const[t,i]of e){const e=g.getPageSize(t);null!=e&&(g.bind(f,l.cw.LINEAR,t,n.dD),C.setUniform2fv("u_mosaicSize",e),C.setUniform1i("u_texture",n.dD),f.drawElements(l.MX.TRIANGLES,i[1],l.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]))}}else f.drawElements(l.MX.TRIANGLES,a.fillIndexCount,l.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.fillIndexStart);e.triangleCount+=a.fillIndexCount/3}}}_drawOutline(e,t,i,n,r,s){const{context:c,displayLevel:u,state:d,painter:p,pixelRatio:f,spriteMosaic:m,requestRender:_,allowDelayedRender:h}=e,v=i.outlineMaterial,g=p.vectorTilesMaterialManager,y=.75/f,x=this._outlineProgramOptions,w=g.getMaterialProgram(c,v,x);if(h&&null!=_&&!w.compiled)return void _();c.useProgram(w),w.setUniformMatrix3fv("u_displayMat3",s===a.fD.VIEWPORT?d.displayMat3:d.displayViewMat3),w.setUniform2fv("u_fillTranslation",r),w.setUniform1f("u_depth",i.z+o),w.setUniform1f("u_outline_width",y);let b=-1;for(const e of n){if(!e.layerData.has(t))continue;e.key.level!==b&&(b=e.key.level,v.setDataUniforms(w,u,i,b,m));const a=e.layerData.get(t);if(a.prepareForRendering(c),!a.outlineIndexCount)continue;const n=a.outlineVAO;null!=n&&(c.bindVAO(n),w.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),c.setStencilFunction(l.wb.EQUAL,e.stencilRef,255),c.drawElements(l.MX.TRIANGLES,a.outlineIndexCount,l.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.outlineIndexStart),e.triangleCount+=a.outlineIndexCount/3)}}}},87190:(e,t,i)=>{i.d(t,{z:()=>o});var a=i(93712),n=i(14266),r=i(29316),l=i(91907);class o extends r.Z{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:r,state:o,painter:s,pixelRatio:c,spriteMosaic:u,styleLayerUID:d,requestRender:p,allowDelayedRender:f}=e;if(!t.some((e=>e.layerData.get(d)?.lineIndexCount??!1)))return;const m=e.styleLayer,_=m.lineMaterial,h=s.vectorTilesMaterialManager,v=m.getPaintValue("line-translate",r),g=m.getPaintValue("line-translate-anchor",r),y=m.getPaintProperty("line-pattern"),x=void 0!==y,w=x&&y.isDataDriven;let b,M;if(x&&!w){const e=y.getValue(r);b=u.getMosaicItemPosition(e)}let S=!1;if(!x){const e=m.getPaintProperty("line-dasharray");if(M=void 0!==e,S=M&&e.isDataDriven,M&&!S){const t=e.getValue(r),i=m.getDashKey(t,m.getLayoutValue("line-cap",r));b=u.getMosaicItemPosition(i)}}const C=1/c,T=this._programOptions;T.pattern=x,T.sdf=M;const R=h.getMaterialProgram(i,_,T);if(f&&null!=p&&!R.compiled)return void p();if(i.useProgram(R),R.setUniformMatrix3fv("u_displayViewMat3",o.displayViewMat3),R.setUniformMatrix3fv("u_displayMat3",g===a.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),R.setUniform2fv("u_lineTranslation",v),R.setUniform1f("u_depth",m.z),R.setUniform1f("u_antialiasing",C),b&&null!=b){const{page:e}=b,t=u.getPageSize(e);null!=t&&(u.bind(i,l.cw.LINEAR,e,n.dD),R.setUniform2fv("u_mosaicSize",t),R.setUniform1i("u_texture",n.dD))}let E=-1;for(const e of t){if(!e.layerData.has(d))continue;e.key.level!==E&&(E=e.key.level,_.setDataUniforms(R,r,m,E,u));const t=2**(r-E)/c;R.setUniform1f("u_zoomFactor",t);const a=e.layerData.get(d);if(!a.lineIndexCount)continue;a.prepareForRendering(i);const o=a.vao;if(null!=o){if(i.bindVAO(o),R.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),i.setStencilFunction(l.wb.EQUAL,e.stencilRef,255),w||S){const e=a.patternMap;if(!e)continue;for(const[t,a]of e){const e=u.getPageSize(t);null!=e&&(u.bind(i,l.cw.LINEAR,t,n.dD),R.setUniform2fv("u_mosaicSize",e),R.setUniform1i("u_texture",n.dD),i.drawElements(l.MX.TRIANGLES,a[1],l.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a[0]))}}else i.drawElements(l.MX.TRIANGLES,a.lineIndexCount,l.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.lineIndexStart);e.triangleCount+=a.lineIndexCount/3}}}}},96049:(e,t,i)=>{i.d(t,{e:()=>u});var a=i(45867),n=i(2509),r=i(93712),l=i(14266),o=i(71200),s=i(29316),c=i(91907);class u extends s.Z{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,a.Ue)()}dispose(){}drawMany(e,t){const i=e.styleLayer;this._drawIcons(e,i,t),this._drawText(e,i,t)}_drawIcons(e,t,i){const{context:a,displayLevel:s,painter:c,spriteMosaic:u,state:d,styleLayerUID:p,requestRender:f,allowDelayedRender:m}=e,_=t.iconMaterial,h=c.vectorTilesMaterialManager;let v,g=!1;for(const e of i)if(e.layerData.has(p)&&(v=e.layerData.get(p),v.iconPerPageElementsMap.size>0)){g=!0;break}if(!g)return;const y=t.getPaintValue("icon-translate",s),x=t.getPaintValue("icon-translate-anchor",s);let w=t.getLayoutValue("icon-rotation-alignment",s);w===r.aF.AUTO&&(w=t.getLayoutValue("symbol-placement",s)===r.R.POINT?r.aF.VIEWPORT:r.aF.MAP);const b=w===r.aF.MAP,M=t.getLayoutValue("icon-keep-upright",s)&&b,S=v.isIconSDF,C=this._iconProgramOptions;C.sdf=S;const T=h.getMaterialProgram(a,_,C);if(m&&null!=f&&!T.compiled)return void f();a.useProgram(T),T.setUniformMatrix3fv("u_displayViewMat3",w===r.aF.MAP?d.displayViewMat3:d.displayMat3),T.setUniformMatrix3fv("u_displayMat3",x===r.fD.VIEWPORT?d.displayMat3:d.displayViewMat3),T.setUniform2fv("u_iconTranslation",y),T.setUniform1f("u_depth",t.z),T.setUniform1f("u_mapRotation",(0,o.s5)(d.rotation)),T.setUniform1f("u_keepUpright",M?1:0),T.setUniform1f("u_level",10*s),T.setUniform1i("u_texture",l.dD),T.setUniform1f("u_fadeDuration",n.v7/1e3);let R=-1;for(const n of i){if(!n.layerData.has(p))continue;if(n.key.level!==R&&(R=n.key.level,_.setDataUniforms(T,s,t,R,u)),v=n.layerData.get(p),0===v.iconPerPageElementsMap.size)continue;v.prepareForRendering(a),v.updateOpacityInfo();const i=v.iconVAO;if(null!=i){a.bindVAO(i),T.setUniformMatrix3fv("u_dvsMat3",n.transforms.displayViewScreenMat3),T.setUniform1f("u_time",(performance.now()-v.lastOpacityUpdate)/1e3);for(const[t,i]of v.iconPerPageElementsMap)this._renderIconRange(e,T,i,t,n)}}}_renderIconRange(e,t,i,a,n){const{context:r,spriteMosaic:o}=e;this._spritesTextureSize[0]=o.getWidth(a)/4,this._spritesTextureSize[1]=o.getHeight(a)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),o.bind(r,c.cw.LINEAR,a,l.dD),this._setStencilState(e,n),r.drawElements(c.MX.TRIANGLES,i[1],c.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),n.triangleCount+=i[1]/3}_drawText(e,t,i){const{context:s,displayLevel:c,glyphMosaic:u,painter:d,pixelRatio:p,spriteMosaic:f,state:m,styleLayerUID:_,requestRender:h,allowDelayedRender:v}=e,g=t.textMaterial,y=d.vectorTilesMaterialManager;let x,w=!1;for(const e of i)if(e.layerData.has(_)&&(x=e.layerData.get(_),x.glyphPerPageElementsMap.size>0)){w=!0;break}if(!w)return;const b=t.getPaintProperty("text-opacity");if(b&&!b.isDataDriven&&0===b.getValue(c))return;const M=t.getPaintProperty("text-color"),S=!M||M.isDataDriven||M.getValue(c)[3]>0,C=t.getPaintProperty("text-halo-width"),T=t.getPaintProperty("text-halo-color"),R=(!C||C.isDataDriven||C.getValue(c)>0)&&(!T||T.isDataDriven||T.getValue(c)[3]>0);if(!S&&!R)return;let E=t.getLayoutValue("text-rotation-alignment",c);E===r.aF.AUTO&&(E=t.getLayoutValue("symbol-placement",c)===r.R.POINT?r.aF.VIEWPORT:r.aF.MAP);const P=E===r.aF.MAP,I=t.getLayoutValue("text-keep-upright",c)&&P,D=.8*3/p;this._glyphTextureSize||(this._glyphTextureSize=(0,a.al)(u.width/4,u.height/4));const L=t.getPaintValue("text-translate",c),U=t.getPaintValue("text-translate-anchor",c),A=this._sdfProgramOptions,O=y.getMaterialProgram(s,g,A);if(v&&null!=h&&!O.compiled)return void h();s.useProgram(O),O.setUniformMatrix3fv("u_displayViewMat3",E===r.aF.MAP?m.displayViewMat3:m.displayMat3),O.setUniformMatrix3fv("u_displayMat3",U===r.fD.VIEWPORT?m.displayMat3:m.displayViewMat3),O.setUniform2fv("u_textTranslation",L),O.setUniform1f("u_depth",t.z+152587890625e-16),O.setUniform2fv("u_mosaicSize",this._glyphTextureSize),O.setUniform1f("u_mapRotation",(0,o.s5)(m.rotation)),O.setUniform1f("u_keepUpright",I?1:0),O.setUniform1f("u_level",10*c),O.setUniform1i("u_texture",l._E),O.setUniform1f("u_antialiasingWidth",D),O.setUniform1f("u_fadeDuration",n.v7/1e3);let z=-1;for(const a of i){if(!a.layerData.has(_))continue;if(a.key.level!==z&&(z=a.key.level,g.setDataUniforms(O,c,t,z,f)),x=a.layerData.get(_),0===x.glyphPerPageElementsMap.size)continue;x.prepareForRendering(s),x.updateOpacityInfo();const i=x.textVAO;if(null==i)continue;s.bindVAO(i),O.setUniformMatrix3fv("u_dvsMat3",a.transforms.displayViewScreenMat3),this._setStencilState(e,a);const n=(performance.now()-x.lastOpacityUpdate)/1e3;O.setUniform1f("u_time",n),x.glyphPerPageElementsMap.forEach(((e,t)=>{this._renderGlyphRange(s,e,t,u,O,R,S,a)}))}}_renderGlyphRange(e,t,i,a,n,r,o,s){a.bind(e,c.cw.LINEAR,i,l._E),r&&(n.setUniform1f("u_halo",1),e.drawElements(c.MX.TRIANGLES,t[1],c.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3),o&&(n.setUniform1f("u_halo",0),e.drawElements(c.MX.TRIANGLES,t[1],c.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3)}_setStencilState(e,t){const{context:i,is3D:a,stencilSymbols:n}=e;if(i.setStencilTestEnabled(!0),n)return i.setStencilWriteMask(255),void i.setStencilFunction(c.wb.ALWAYS,t.stencilRef,255);i.setStencilWriteMask(0),a?i.setStencilFunction(c.wb.EQUAL,t.stencilRef,255):i.setStencilFunction(c.wb.GREATER,255,255)}}},28800:(e,t,i)=>{i.d(t,{A:()=>u});var a=i(36663),n=i(23148),r=i(78668),l=i(76868),o=i(81977),s=(i(39994),i(13802),i(4157),i(40266)),c=i(64862);const u=e=>{let t=class extends e{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(){super.postscript(),(0,c.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,n.kB)((()=>e.abort()))),await(0,l.whenOnce)((()=>this.view.defaultsFromMap?.heightModelInfoReady),t),(0,r.k_)(t);const i=(0,c.Wt)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}};return(0,a._)([(0,o.Cb)()],t.prototype,"view",void 0),(0,a._)([(0,o.Cb)()],t.prototype,"slicePlaneEnabled",void 0),t=(0,a._)([(0,s.j)("esri.views.3d.layers.LayerView3D")],t),t}},8712:(e,t,i)=>{i.d(t,{r:()=>p});var a=i(36663),n=i(70375),r=i(76868),l=i(81977),o=(i(39994),i(13802),i(4157),i(40266)),s=i(70633),c=i(57686),u=i(13809),d=i(42780);const p=e=>{let t=class extends e{constructor(){super(...arguments),this.hasMixedImageFormats=!0}get imageFormatIsOpaque(){return!1}get fullExtent(){return this.layer.fullExtent}get isOpaque(){return this.fullOpacity>=1&&this.imageFormatIsOpaque}get visibleAtCurrentScale(){if(!(0,d.Av)(this.layer.minScale,this.layer.maxScale)||!this.view.scale)return!0;const e=Math.round(this.view.basemapTerrain.tilingScheme.levelAtScale(this.view.scale));return e>=this.displayLevelRange.minLevel&&e<=this.displayLevelRange.maxLevel}get dataScaleRange(){const e=this.tileInfo.lods;let t=e[0].scale,i=e[e.length-1].scale;if("tilemapCache"in this.layer&&this.layer.tilemapCache){const{effectiveMinLOD:e,effectiveMaxLOD:a}=this.layer.tilemapCache;t=this.tileInfo.lodAt(e).scale,i=this.tileInfo.lodAt(a).scale}return{minScale:t,maxScale:i}}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready&&(0,d.Cy)(e)&&this.visibleAtCurrentTimeExtent||!1}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange;return this.levelRangeFromScaleRange(e,t)}get displayLevelRange(){const e=this.layer.minScale||this.dataScaleRange.minScale,t=this.layer.maxScale||this.dataScaleRange.maxScale,i=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale&&i.maxLevel++,i}get performanceInfo(){return new s.W(this.view.basemapTerrain.getUsedMemoryForLayerView(this))}getTileUrl(e){return this.layer.getTileUrl(e[0],e[1],e[2])}_addTilingSchemeMatchPromise(){if(null==this.fullExtent)return this.addResolvingPromise(Promise.reject(new n.Z("tilingscheme:extent-not-defined","This layer doesn't define a fullExtent.")));const e=this._getTileInfoSupportError(this.tileInfo,this.fullExtent);if(e)return this.addResolvingPromise(Promise.reject(e));this.addResolvingPromise((0,r.whenOnce)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const e=this.view.basemapTerrain.tilingScheme,t="tilemapCache"in this.layer?this.layer.tilemapCache?.effectiveMaxLOD:void 0,i=this._getTileInfoCompatibilityError(this.tileInfo,e,t);if(i)throw i})))}_getTileInfoSupportError(e,t){const i=(0,u.er)(e,t,this.view.spatialReference,this.view.state.viewingMode,"tilemapCache"in this.layer?this.layer.tilemapCache?.effectiveMaxLOD:void 0);if(!i)return;const a={layer:this.layer,error:i};switch(i.name){case"tilingscheme:spatial-reference-mismatch":case"tilingscheme:global-unsupported-spatial-reference":case"tilingscheme:local-unsupported-spatial-reference":return new n.Z("layerview:spatial-reference-incompatible","The spatial reference of this layer does not meet the requirements of the view",a);default:return new n.Z("layerview:tiling-scheme-unsupported","The tiling scheme of this layer is not supported by SceneView",a)}}_getTileInfoCompatibilityError(e,t,i){return null!=e&&t.compatibleWith(e,i)?null:new n.Z("layerview:tiling-scheme-incompatible","The tiling scheme of this layer is incompatible with the tiling scheme of the surface")}levelRangeFromScaleRange(e,t){const i={minLevel:0,maxLevel:1/0},a=this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.tilingScheme;if(!a)return i;const n=a.levels[0],r=e=>{const t=Math.log(n.scale/e)/Math.LN2;return.5-Math.abs(.5-t%1)<1e-9?Math.round(t):Math.ceil(t)};return null!=e&&e>0&&(i.minLevel=Math.max(0,r(e))),null!=t&&t>0&&(i.maxLevel=Math.max(0,r(t))),i}isUpdating(){return!!(this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.updating)}};return(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"imageFormatIsOpaque",null),(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"updating",void 0),(0,a._)([(0,l.Cb)(c.q)],t.prototype,"updatingProgress",void 0),(0,a._)([(0,l.Cb)(c.V)],t.prototype,"updatingProgressValue",void 0),(0,a._)([(0,l.Cb)()],t.prototype,"hasMixedImageFormats",void 0),(0,a._)([(0,l.Cb)()],t.prototype,"fullExtent",null),(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"isOpaque",null),(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"visibleAtCurrentScale",null),(0,a._)([(0,l.Cb)()],t.prototype,"dataScaleRange",null),(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"dataLevelRange",null),(0,a._)([(0,l.Cb)({readOnly:!0})],t.prototype,"displayLevelRange",null),(0,a._)([(0,l.Cb)()],t.prototype,"layer",void 0),t=(0,a._)([(0,o.j)("esri.views.3d.layers.TiledLayerView3D")],t),t}},35399:(e,t,i)=>{i.r(t),i.d(t,{default:()=>F});var a=i(36663),n=i(70375),r=i(39994),l=i(61681),o=i(78668),s=i(76868),c=i(81977),u=(i(13802),i(4157),i(40266));class d{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,a=0;const n=this._shift+this.getLevelShift(e[0]);if(n){const r=(1<<n)-1,l=t/(this._scale*(1<<n-1));i=(e[2]&r)*l,a=(e[1]&r)*l}return[i,a]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}}var p=i(40366),f=i(38642),m=i(24568),_=i(28249),h=i(31555),v=i(80361),g=i(87241);class y extends _.m{constructor(e,t,i,a){super(e,t,i,e.tileInfo.lods.length-1),this._memCache=a,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new v.Z(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t){const i=new g.Z(e[0],e[1],e[2],0);let a=this._memCache.get(i.id);if(a)return a.retain(),a;const n=await this._getVectorTileData(i);if((0,o.k_)(t),!this._layer)return null;if(a=this._memCache.get(i.id),a)return a.retain(),a;const r=this._layer.tileInfo.getTileBounds((0,m.Ue)(),i),l=this._tileInfoView.getTileResolution(e[0]);return a=new h.i(i,l,r[0],r[3],512,512,this._styleRepository,this._memCache),a.setData(n),n&&(a.retain(),this._memCache.put(i.id,a,p.M4)),a.neededForCoverage=!0,a.transforms.tileUnitsToPixels=(0,f.al)(1/8,0,0,0,1/8,0,0,0,1),a}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,a={signal:i.signal},n=this._getParsedVectorTileData(e,a).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,n),this._ongoingRequestToController.set(t,i),n}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}}var x=i(10929),w=i(92677),b=i(28035),M=i(87190),S=i(96049);const C={vtlBackground:x.J,vtlFill:b.R,vtlLine:M.z,vtlCircle:w.j,vtlSymbol:S.e};var T=i(43057),R=i(93712),E=i(91907);const P=1e-6;class I{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new T.Z}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=(0,l.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,t,i){const a=i.layers;e.renderPass="translucent";let n=this._brushCache.vtlSymbol;null==n&&(n=new C.vtlSymbol,this._brushCache.vtlSymbol=n),D[0]=t;for(let t=0;t<a.length;t++){const i=a[t];if(i.type!==R.fR.SYMBOL)continue;const r=i.getLayoutProperty("visibility");if(r&&r.getValue()===R.EE.NONE)continue;const l=e.displayLevel;void 0!==i.minzoom&&i.minzoom>l+P||void 0!==i.maxzoom&&i.maxzoom<=l-P||(e.styleLayerUID=i.uid,e.styleLayer=i,n.drawMany(e,D))}D[0]=null}drawBackground(e,t,i){if(0===i.backgroundBucketIds.length)return;const{context:a,displayLevel:n,requiredLevel:r}=e;t.key.level=r,a.setBlendingEnabled(!0),a.setDepthTestEnabled(!1),a.setStencilTestEnabled(!1),e.renderPass="background";let l=this._brushCache.vtlBackground;null==l&&(l=new C.vtlBackground,this._brushCache.vtlBackground=l),D[0]=t,i.backgroundBucketIds.forEach((t=>{const a=i.getLayerById(t);if(a.type!==R.fR.BACKGROUND)return;const r=a.getLayoutProperty("visibility");r&&r.getValue()===R.EE.NONE||void 0!==a.minzoom&&a.minzoom>n+P||void 0!==a.maxzoom&&a.maxzoom<=n-P||(e.styleLayerUID=a.uid,e.styleLayer=a,l.drawMany(e,D))})),D[0]=null}drawTile(e,t,i,a){const{context:n}=e,r=i.layers;n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(E.wb.LEQUAL);const l=r.filter((e=>{if(null!=a&&a!==e.type||!t.layerData.has(e.uid))return!1;return e.getLayoutProperty("visibility")?.getValue()!==R.EE.NONE}));e.renderPass="opaque";for(let i=l.length-1;i>=0;--i)this._renderStyleLayer(l[i],e,t);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(E.zi.ONE,E.zi.ONE_MINUS_SRC_ALPHA,E.zi.ONE,E.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent",l.forEach((i=>this._renderStyleLayer(i,e,t))),n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,t,i){const{renderPass:a}=t;let n;switch(e.type){case R.fR.BACKGROUND:if("background"!==a)return;n=this._brushCache.vtlBackground,n||(n=new C.vtlBackground,this._brushCache.vtlBackground=n);break;case R.fR.FILL:if("opaque"!==a&&"translucent"!==t.renderPass)return;n=this._brushCache.vtlFill,null==n&&(n=new C.vtlFill,this._brushCache.vtlFill=n);break;case R.fR.LINE:if("translucent"!==a)return;n=this._brushCache.vtlLine,null==n&&(n=new C.vtlLine,this._brushCache.vtlLine=n);break;case R.fR.CIRCLE:if("translucent"!==a)return;n=this._brushCache.vtlCircle,null==n&&(n=new C.vtlCircle,this._brushCache.vtlCircle=n);break;case R.fR.SYMBOL:if("translucent"!==a)return;n=this._brushCache.vtlSymbol,null==n&&(n=new C.vtlSymbol,this._brushCache.vtlSymbol=n)}const{displayLevel:r}=t,{minzoom:l,maxzoom:o}=e;if(void 0!==l&&l>r+P||void 0!==o&&o<=r-P)return;const{context:s}=t;s.setStencilTestEnabled(!1),s.setStencilWriteMask(0),t.styleLayerUID=e.uid,t.styleLayer=e,D[0]=i,n.drawMany(t,D),D[0]=null}}const D=[null];var L=i(63043),U=i(28800),A=i(8712),O=i(13809),z=i(26216);let V=class extends((0,A.r)((0,U.A)(z.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=(0,r.Z)("disable-feature:vtl-level-shift")?0:1}initialize(){if(null==this.layer.fullExtent)return void this.addResolvingPromise(Promise.reject(new n.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:e,spatialReference:t,state:i,viewingMode:a}=this.view,r="local"===a&&!(0,O.jO)(t)||O.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),l=this._getTileInfoSupportError(r,this.layer.fullExtent);if(null!=l)return this.addResolvingPromise(Promise.reject(l));const c=(0,s.whenOnce)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const t=e.tilingScheme,i=t.pixelSize,a=256===i?1:2,n=e.spatialReference?.isGeographic&&256===i?1:0,r=e.spatialReference?.isGeographic||256!==i?0:1;let l;this.schemaHelper=new d(a,n,this.levelShift+r),l=256===i||512===i?this.layer.tileInfo.getCompatibleForVTL(i):this.layer.tileInfo;const o=this._getTileInfoCompatibilityError(l,t);if(o)throw o;this.tileInfo=l}));this._tileHandlerController=new AbortController;const u=this.view.resourceController;this._memCache=u.memoryController.newCache(`vtl-${this.layer.uid}`,(e=>e.release())),this.addHandles((0,s.watch)((()=>this.view.qualitySettings.memoryLimit),(e=>this._memCache.maxSize=Math.ceil(e/10*1048576)),s.syncAndInitial));const p=new L.Z(this.layer.currentStyleInfo.style);this._tileHandler=new y(this.layer,p,i.contentPixelRatio,this._memCache);const f=this._tileHandlerController.signal,m=function(e){return t=>e.immediate.schedule(t)}(u),_=this._tileHandler.start({signal:f,schedule:m}),h=this._tileHandler.spriteMosaic;h.then((e=>{!(0,o.Hc)(f)&&this._tileHandler&&(this.painter=new I(e,this._tileHandler.glyphMosaic))})),_.then((()=>this._tileHandlerController=null));const v=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const e=this.layer.currentStyleInfo.style,t=this.view.state?.contentPixelRatio??1,i=new L.Z(e),a=new y(this.layer,i,t,this._memCache),n=a.start({signal:this._tileHandlerController.signal,schedule:m}),r=a.spriteMosaic;n.then((()=>this._tileHandlerController=null)),this._updatingHandles.addPromise(Promise.all([n,r]).then((([,e])=>{const t=this._tileHandler,i=this.painter;this.painter=new I(e,a.glyphMosaic),this._tileHandler=a,this.emit("data-changed"),t.destroy(),i&&i.dispose()})))};this._updatingHandles.add((()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio})),v),this.addHandles([this.layer.on("paint-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-change",v),this.layer.on("delete-style-layer",v),this.layer.on("spriteSource-change",(()=>this.emit("data-changed"))),this.layer.on("layout-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-visibility-change",(()=>this.emit("data-changed")))]);const g=Promise.all([c,_,h]);this.addResolvingPromise(g)}destroy(){this.painter=(0,l.M2)(this.painter),this._tileHandlerController=(0,l.IM)(this._tileHandlerController),this._tileHandler=(0,l.SC)(this._tileHandler),this._memCache=(0,l.SC)(this._memCache)}get contentZoom(){return(0,r.Z)("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const e=this.tileInfo.lods,t=this.layer.minScale||e[0].scale,i=this.layer.maxScale||e[e.length-1].scale,a=this.levelRangeFromScaleRange(t,i);return this.layer.maxScale?a.maxLevel++:a.maxLevel+=this.levelShift,a}get dataScaleRange(){const e=this.tileInfo.lods;return{minScale:e[0].scale,maxScale:e[e.length-1].scale}}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange,i=this.levelRangeFromScaleRange(e,t);return 1===i.minLevel&&256===this.tileInfo.size[0]&&(i.minLevel=0),i.maxLevel+=this.levelShift,i}async fetchTile(e,t){const i=this.schemaHelper.getLevelRowColumn(e);return this._tileHandler.getVectorTile(i,t)}get hasVisibleFeatures(){return!0}};(0,a._)([(0,c.Cb)()],V.prototype,"layer",void 0),(0,a._)([(0,c.Cb)()],V.prototype,"levelShift",void 0),(0,a._)([(0,c.Cb)()],V.prototype,"contentZoom",null),(0,a._)([(0,c.Cb)()],V.prototype,"displayLevelRange",null),(0,a._)([(0,c.Cb)()],V.prototype,"tileInfo",void 0),(0,a._)([(0,c.Cb)()],V.prototype,"dataScaleRange",null),(0,a._)([(0,c.Cb)()],V.prototype,"dataLevelRange",null),(0,a._)([(0,c.Cb)()],V.prototype,"updatingProgressValue",void 0),V=(0,a._)([(0,u.j)("esri.views.3d.layers.VectorTileLayerView3D")],V);const F=V},26216:(e,t,i)=>{i.d(t,{Z:()=>_});var a=i(36663),n=i(74396),r=i(31355),l=i(86618),o=i(13802),s=i(61681),c=i(64189),u=i(81977),d=(i(39994),i(4157),i(40266)),p=i(98940),f=i(42780);let m=class extends(l.Z.IdentifiableMixin(c.Z.EsriPromiseMixin(r.Z.EventedMixin(n.Z)))){get spatialReferenceSupported(){return!0}constructor(e){super(e),this._updatingHandles=new p.R,this.layer=null,this.parent=null}initialize(){this.when().catch((e=>{if("layerview:create-error"!==e.name){const t=this.layer&&this.layer.id||"no id",i=this.layer?.title||"no title";o.Z.getLogger(this).error("#resolve()",`Failed to resolve layer view (layer title: '${i}', id: '${t}')`,e)}}))}destroy(){this._updatingHandles=(0,s.SC)(this._updatingHandles)}get fullOpacity(){return(this.layer?.opacity??1)*(this.parent?.fullOpacity??1)}get suspended(){return this.destroyed||!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this._updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get updateSuspended(){return this.suspended}get visible(){return!0===this.layer?.visible}set visible(e){this._overrideIfSome("visible",e)}get visibleAtCurrentScale(){return!0}get visibleAtCurrentTimeExtent(){const e=this.view.timeExtent,t=this.layer?.visibilityTimeExtent;return!e||!t||!e.intersection(t).isEmpty}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&this.layer?.loaded&&this.parent&&!this.parent.suspended&&this.view?.ready&&(0,f.Cy)(e)&&this.visibleAtCurrentScale&&this.visibleAtCurrentTimeExtent||!1}getSuspendInfo(){const e=this.parent?.suspended?this.parent.suspendInfo:{};this.view?.ready||(e.viewNotReady=!0),this.layer&&this.layer.loaded||(e.layerNotLoaded=!0);const t=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return(0,f.Cy)(t)&&this.visibleAtCurrentScale||(e.outsideScaleRange=!0),this.visibleAtCurrentTimeExtent||(e.outsideVisibilityTimeExtent=!0),this.visible||(e.layerInvisible=!0),e}isUpdating(){return!1}};(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"spatialReferenceSupported",null),(0,a._)([(0,u.Cb)()],m.prototype,"view",void 0),(0,a._)([(0,u.Cb)()],m.prototype,"fullOpacity",null),(0,a._)([(0,u.Cb)()],m.prototype,"layer",void 0),(0,a._)([(0,u.Cb)()],m.prototype,"parent",void 0),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"suspended",null),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"suspendInfo",null),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"legendEnabled",null),(0,a._)([(0,u.Cb)({type:Boolean,readOnly:!0})],m.prototype,"updating",null),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"updatingProgress",null),(0,a._)([(0,u.Cb)()],m.prototype,"updateSuspended",null),(0,a._)([(0,u.Cb)()],m.prototype,"visible",null),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"visibleAtCurrentScale",null),(0,a._)([(0,u.Cb)({readOnly:!0})],m.prototype,"visibleAtCurrentTimeExtent",null),m=(0,a._)([(0,d.j)("esri.views.layers.LayerView")],m);const _=m},78311:(e,t,i)=>{i.d(t,{B:()=>a});class a{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,t=new Map){if(t.has(e))return t.get(e);const i=this._read(e);if(!i)throw new Error(`cannot find shader file ${e}`);const a=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let n=a.exec(i);const r=[];for(;null!=n;)r.push({path:n[1],start:n.index,length:n[0].length}),n=a.exec(i);let l=0,o="";return r.forEach((e=>{o+=i.slice(l,e.start),o+=t.has(e.path)?"":this._resolve(e.path,t),l=e.start+e.length})),o+=i.slice(l),t.set(e,o),o}_read(e){return this._readFile(e)}}},73353:(e,t,i)=>{function a(e){const{options:t,value:i}=e;return"number"==typeof t[i]}function n(e){let t="";for(const i in e){const n=e[i];if("boolean"==typeof n)n&&(t+=`#define ${i}\n`);else if("number"==typeof n)t+=`#define ${i} ${n.toFixed()}\n`;else if("object"==typeof n)if(a(n)){const{value:e,options:a,namespace:r}=n,l=r?`${r}_`:"";for(const e in a)t+=`#define ${l}${e} ${a[e].toFixed()}\n`;t+=`#define ${i} ${l}${e}\n`}else{const e=n.options;let a=0;for(const i in e)t+=`#define ${e[i]} ${(a++).toFixed()}\n`;t+=`#define ${i} ${e[n.value]}\n`}}return t}i.d(t,{K:()=>n})}}]);