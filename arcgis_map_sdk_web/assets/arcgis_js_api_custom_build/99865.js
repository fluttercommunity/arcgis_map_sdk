"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[99865],{65323:(e,t,r)=>{r.d(t,{$:()=>n,l:()=>i});const n=50,i=5},69803:(e,t,r)=>{r.d(t,{TS:()=>d,wK:()=>h});var n=r(17321),i=r(10186),s=r(90819),o=r(14685),a=r(85130),l=r(29927),c=r(35925),u=r(39536),p=r(65323);function d(e,t,r){const n=1===e?10:e;return n**(r?Math.round(function(e,t){return Math.log(e)/Math.log(t)}(p.$/t,n)):0)}function h(e,t,r){const p="number"==typeof e?null:e,d=r??p?.spatialReference;if(null==d||!(0,c.JY)(d)||function(e){const{isGeographic:t,isWebMercator:r}=e;return!t&&!r}(d))return(0,n.c9)(d);let h=p?.x??e,g=p?.y??t;const f=1/Math.sqrt(2);let S=h+f,y=g+f;const{isWebMercator:w,isGeographic:v}=d;let b=v&&!(0,a.Gb)(d)?o.Z.WGS84:d;if(w){let e=new i.Z({x:h,y:g,spatialReference:d});(0,u.Sx)(e,!0,e),h=e.x,g=e.y,e=new i.Z({x:S,y,spatialReference:d}),(0,u.Sx)(e,!0,e),S=e.x,y=e.y,b=o.Z.WGS84}const M=new s.Z({paths:[[[h,g],[S,y]]],spatialReference:b}),R=(0,l.hR)(M,10);let C;try{[C]=(0,a.Jf)([R],"meters")}catch{return(0,n.c9)(d)}return C}},99865:(e,t,r)=>{r.r(t),r.d(t,{GridSnappingEngine:()=>b});var n=r(36663),i=r(74396),s=r(13802),o=r(19431),a=r(17321),l=r(81977),c=(r(39994),r(4157),r(40266)),u=r(86717),p=r(90472),d=r(29927),h=r(68577),g=r(65323),f=r(69803),S=r(51633),y=r(22519),w=r(36485),v=r(66200);let b=class extends i.Z{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:(0,o.Vl)(this.view.rotation??0)}get gridRotation(){return(0,o.Vl)(this.grid?.rotation??0)}get gridCenter(){const{spatialReference:e,grid:t}=this;if(!t||!e||!(0,p.isLoadedOrLoadFor)(t.center.spatialReference,e))return null;try{const r=(0,p.project)(t.center,e),n=e.isWrappable&&null!=this.view?.center?(0,d.it)(r.x,this.view.center.x,e):r.x;return(0,S.Ue)(n,r.y,r.z)}catch(e){return s.Z.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",e),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:t}=this;if(!t||!e)return 1;const{majorLineInterval:r,dynamicScaling:n}=t;return r<1?null:(0,f.TS)(r,e,n)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?(0,a.En)(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return null==e?null:e*(0,h.dp)(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?(0,f.wK)(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:t}=this;return t&&e?e/t:null}get updating(){return null!=this.grid&&null!=this.spatialReference&&null==this.viewMetersPerSRUnit}async fetchCandidates(e,t,r){const{options:n,view:i}=this;if(!n?.effectiveGridEnabled||!i.grid||r.feature?.attributes&&y.Ry in r.feature.attributes)return[];const s=r.coordinateHelper.arrayToPoint(e),o=n.distance*("touch"===r.pointer?n.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,o)}fetchCandidatesSync(e,t){const r=[],{grid:n,effectiveViewRotation:i,gridRotation:s,gridCenter:o,viewMetersPerPixel:a,viewMetersPerSRUnit:l,offsetScaleFactor:c,spatialReference:u,gridMetersPerStride:d,pixelsPerStride:h}=this;if(!(n&&a&&l&&o&&u&&c&&d&&h))return r;if(!n.dynamicScaling&&h<g.l)return r;if(!(0,p.isLoadedOrLoadFor)(e.spatialReference,u))return r;const f=(0,p.project)(e,u),y=(0,S.Ue)(f.x,f.y,f.z),b=M(y,-s,o,-i),x=d/l*c,_=R(b,x,o),{shouldSnapX:U,shouldSnapY:G}=C(_,b,t,a,l);if(!U&&!G)return[];const L=(0,S.Ue)((U?_:b)[0],(G?_:b)[1]),m=M(L,s,o,i),Z=M(_,s,o,i);if(G){const e=P(_,b,x,"y"),t=M(e,s,o,i);r.push(new v.u({lineStart:Z,lineEnd:t,targetPoint:m,isDraped:!1}))}if(U){const e=P(_,b,x,"x"),t=M(e,s,o,i);r.push(new v.u({lineStart:Z,lineEnd:t,targetPoint:m,isDraped:!1}))}return U&&G&&r.push(new w.m(m,r[0],r[1],!1)),r}};(0,n._)([(0,l.Cb)({constructOnly:!0})],b.prototype,"view",void 0),(0,n._)([(0,l.Cb)()],b.prototype,"options",void 0),(0,n._)([(0,l.Cb)()],b.prototype,"grid",null),(0,n._)([(0,l.Cb)()],b.prototype,"effectiveViewRotation",null),(0,n._)([(0,l.Cb)()],b.prototype,"gridRotation",null),(0,n._)([(0,l.Cb)()],b.prototype,"gridCenter",null),(0,n._)([(0,l.Cb)()],b.prototype,"offsetScaleFactor",null),(0,n._)([(0,l.Cb)()],b.prototype,"spatialReference",null),(0,n._)([(0,l.Cb)()],b.prototype,"gridMetersPerStride",null),(0,n._)([(0,l.Cb)()],b.prototype,"viewMetersPerPixel",null),(0,n._)([(0,l.Cb)()],b.prototype,"viewMetersPerSRUnit",null),(0,n._)([(0,l.Cb)()],b.prototype,"pixelsPerStride",null),(0,n._)([(0,l.Cb)()],b.prototype,"updating",null),b=(0,n._)([(0,c.j)("esri.views.interactive.snapping.GridSnappingEngine")],b);const M=(e,t,r,n)=>{const i=(0,S.by)(e[0],e[1],e[2]);return(0,u.L)(i,(0,u.L)(i,i,r,t),r,n)},R=(e,t,r)=>{const n=(e[0]-r[0])/t,i=(e[1]-r[1])/t,s=Math.trunc(n),o=Math.trunc(i),a=Math.round(n%1),l=Math.round(i%1),c=r[0]+(s+a)*t,u=r[1]+(o+l)*t;return(0,S.Ue)(c,u)},C=(e,t,r,n,i)=>{if(n<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-t[0])/n,o=(e[1]-t[1])/n;return{shouldSnapX:Math.abs(s*i)<r,shouldSnapY:Math.abs(o*i)<r}},P=(e,t,r,n)=>{if("y"===n){const n=t[0]>e[0]?1:-1;return(0,S.Ue)(e[0]+r*n,e[1])}const i=t[1]>e[1]?1:-1;return(0,S.Ue)(e[0],e[1]+r*i)}}}]);